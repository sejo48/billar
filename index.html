<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador de Trayectoria de Billar</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Librería de Sonido (Tone.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo para la fuente Inter */
        html, body {
            height: 100%; /* Asegurar que html y body ocupen toda la altura */
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevenir scroll general */
        }
        /* Asegura que el canvas tenga un fondo, en caso de que tailwind no cargue */
        canvas {
            background-color: #059669; /* Verde billar */
            display: block; /* Evita espacios extra */
        }
        /* --- INICIO CAMBIO: Cursor dinámico --- */
        #poolTable {
            cursor: crosshair; /* Cursor para apuntar en la mesa */
        }
        body.aim-locked #poolTable {
            cursor: default; /* Cursor normal cuando la mira está bloqueada */
        }
        /* --- FIN CAMBIO --- */
        #spinControlCanvas {
            cursor: pointer; /* Cursor para el control de efecto */
        }
        /* Estilo para la fuente elegante */
        .elegant-script {
            font-family: 'Dancing Script', cursive;
        }

        /* Estilos para la barra de fuerza vertical */
        #powerBar {
            -webkit-appearance: slider-vertical; /* Chrome, Safari, Opera */
            writing-mode: bt-lr; /* Firefox */
            width: 12px;
            height: 150px;
            padding: 0 5px;
            transform: rotate(180deg); /* <-- NUEVO: Invertir la barra */
        }
        #powerBar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            background: #2563eb; /* Color azul */
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #f0f0f0;
        }
        #powerBar::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #f0f0f0;
        }

        /* Estilos para Pantalla Completa */
        body.in-fullscreen {
            padding: 0; 
        }
        body.in-fullscreen #main-container {
            padding: 0;
            height: 100%; 
            max-width: 100%;
        }
        body.in-fullscreen #header-block,
        body.in-fullscreen #footer-credits { 
            display: none;
        }
        body.in-fullscreen #main-content-wrapper {
            /* height: 100%; */ /* <-- CORRECCIÓN: Eliminada esta línea que causaba el problema */
        }
        body.in-fullscreen #table-wrapper {
            height: 100%; 
            max-height: 100%;
            padding: 0;
        }
        body.in-fullscreen #controls-wrapper {
            /* display: none; */ /* <-- CORRECCIÓN: Eliminada esta línea */
        }
        @media (min-width: 768px) {
            body.in-fullscreen #controls-wrapper {
                /* display: flex; */ /* <-- CORRECCIÓN: Eliminado todo el bloque @media */
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center p-2 h-full">

    <div id="main-container" class="w-full max-w-7xl flex flex-col md:flex-row items-start flex-grow min-h-0 gap-4">

        <!-- Contenedor Principal (Izquierda) -->
        <div id="main-content-wrapper" class="flex-1 flex flex-col items-center w-full min-h-0 h-full">
            <!-- BLOQUE SUPERIOR: Título, Instrucciones -->
            <div id="header-block" class="flex flex-col items-center w-full px-2 py-2 gap-2 flex-shrink-0 text-center">
                <h1 class="text-2xl md:text-3xl font-bold text-white">Simulador de Billar</h1>
                <!-- --- INICIO CAMBIO: Instrucciones actualizadas --- -->
                <p class="text-sm md:text-base text-gray-400 mt-1">
                    Apunta con el ratón. <b>Haz clic en la mesa para bloquear la mira.</b> Usa los controles para disparar.
                </p>
                <!-- --- FIN CAMBIO --- -->
            </div>

            <!-- BLOQUE CENTRAL: Mesa de Billar -->
            <div id="table-wrapper" class="flex-1 w-full flex items-center justify-center min-h-0">
                <div class="aspect-[2/1] w-full max-w-full max-h-full bg-yellow-900 border-4 md:border-8 border-yellow-800 rounded-lg shadow-2xl overflow-hidden">
                    <canvas id="poolTable" class="w-full h-full"></canvas>
                </div>
            </div>

            <!-- Créditos (movidos al final del contenedor izquierdo) -->
            <div id="footer-credits" class="py-2 flex-shrink-0">
                <p class="elegant-script text-lg md:text-xl text-gray-500 mt-2">
                    Por Jorge Hernández
                </p>
            </div>
        </div>

        <!-- Nuevo Panel de Controles (Derecha) -->
        <div id="controls-wrapper" class="w-full md:w-48 flex flex-row md:flex-col items-center md:items-center justify-around md:justify-start bg-gray-800 rounded-lg p-4 gap-6 flex-shrink-0">
            
            <!-- Control de Efecto -->
            <div class="flex flex-col items-center p-2 rounded-lg bg-gray-700 shadow-lg border border-gray-600">
                <canvas id="spinControlCanvas"></canvas>
                <span class="text-xs md:text-sm text-gray-400 mt-2">Efecto</span>
            </div>

            <!-- Barra de Fuerza -->
            <div class="flex flex-col items-center gap-2">
                <!-- --- INICIO CAMBIO: Barra invertida (etiqueta movida) --- -->
                <input type="range" id="powerBar" min="0" max="100" value="0" step="1" orient="vertical">
                <label for="powerBar" class="text-sm text-gray-400">Fuerza</label>
                <!-- --- FIN CAMBIO --- -->
            </div>

            <!-- Botones de Acción -->
            <div class="flex flex-col gap-4 mt-4">
                <button id="resetButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 shadow-lg" title="Reinicia las bolas a su posición inicial o restaura la posición del último tiro.">
                    Reiniciar
                </button>
                <button id="fullscreenButton" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 shadow-lg" title="Activar/Desactivar pantalla completa">
                    Completa
                </button>
            </div>

        </div>
    </div>


    <script>
        // --- 1. CONFIGURACIÓN INICIAL ---
        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const canvasSpin = document.getElementById('spinControlCanvas');
        const ctxSpin = canvasSpin.getContext('2d');
        const powerBar = document.getElementById('powerBar');
        
        // --- INICIO CAMBIO: Detección Táctil ---
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        // --- FIN CAMBIO ---

        // --- 2. ESTADO DE LA SIMULACIÓN ---
        let cueBall = { x: 0, y: 0, vx: 0, vy: 0, active: true };
        let blackBall = { x: 0, y: 0, vx: 0, vy: 0, active: true };
        let balls = [cueBall, blackBall];

        let lastCueBallPos = null, lastBlackBallPos = null, wasLastBlackBallActive = true; 
        let mousePos = { x: 0, y: 0 };
        let draggingBall = null;
        let isSettingSpin = false;

        // --- INICIO CAMBIO: Nuevo estado 'aimLocked' ---
        let gameState = 'aiming'; // 'aiming', 'aimLocked', 'simulating'
        // --- FIN CAMBIO ---
        let aimDir = { x: 1, y: 0 };

        let spinEffect = { x: 0, y: 0 };
        let spinBallControl = { x: 0, y: 0, radius: 0 };
        let spinIndicator = { x: 0, y: 0 };

        // --- 3. CONSTANTES DE FÍSICA Y MESA ---
        let TABLE_WIDTH = 0, TABLE_HEIGHT = 0;
        let CUSHION_SIZE;
        let BALL_RADIUS;
        let POCKET_RADIUS;
        let POCKETS = [];
        let PLAYABLE_RECT = {};

        const FRICTION = 0.99; 
        const MIN_SPEED = 0.05;
        const SPIN_FACTOR_CUSHION = 0.4; 
        const POWER_MULTIPLIER = 0.22; 
        const RESTITUTION = 0.95; 

        // --- 4. SONIDOS (Tone.js) ---
        let soundsReady = false;
        let cueHitSound, ballCollisionSound, cushionHitSound, pocketSound;

        function initSounds() {
             if (soundsReady) return;
             try {
                 cueHitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                 ballCollisionSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 5, envelope: { attack: 0.001, decay: 0.15, sustain: 0.01, release: 0.1 } }).toDestination();
                 ballCollisionSound.volume.value = -6;
                 cushionHitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 1, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
                 cushionHitSound.volume.value = -12;
                 pocketSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                 pocketSound.volume.value = -6;
                 soundsReady = true;
             } catch (e) { console.error("Error initializing sounds:", e); soundsReady = false; }
        }

        async function startAudioContext() {
             if (Tone.context.state !== 'running') {
                 try { await Tone.start(); console.log("Audio context started"); } 
                 catch (e) { console.error("Error starting audio context:", e); return; }
             }
             if (!soundsReady) { initSounds(); }
        }

        function setupCanvas() {
             const container = canvas.parentElement;
             if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
                 requestAnimationFrame(setupCanvas); return;
             }
             canvas.width = container.clientWidth;
             canvas.height = container.clientHeight;
             if (canvas.width <= 0 || canvas.height <= 0 || !isFinite(canvas.width) || !isFinite(canvas.height)) {
                 console.warn("Invalid canvas dimensions. Retrying.");
                 requestAnimationFrame(setupCanvas); return;
             }
             TABLE_WIDTH = canvas.width; TABLE_HEIGHT = canvas.height;
             CUSHION_SIZE = TABLE_WIDTH * 0.045; BALL_RADIUS = TABLE_WIDTH * 0.015; 
             BALL_RADIUS = Math.max(BALL_RADIUS, 5); POCKET_RADIUS = BALL_RADIUS * 1.8;
             PLAYABLE_RECT = {
                 left: CUSHION_SIZE, top: CUSHION_SIZE,
                 width: TABLE_WIDTH - 2 * CUSHION_SIZE, height: TABLE_HEIGHT - 2 * CUSHION_SIZE,
                 right: TABLE_WIDTH - CUSHION_SIZE, bottom: TABLE_HEIGHT - CUSHION_SIZE
             };
             if (PLAYABLE_RECT.width <= 0 || PLAYABLE_RECT.height <= 0) {
                  console.warn("Invalid playable rect dimensions."); POCKETS = []; return;
             }
             POCKETS = [
                 { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.top }, { x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.top }, { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.top },
                 { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.bottom },{ x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.bottom }, { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.bottom }
             ];
             if ((gameState === 'aiming' || gameState === 'aimLocked') && !draggingBall) {
                 if (lastCueBallPos === null || lastBlackBallPos === null) { resetToStartPositions(); } 
                 else { 
                     balls.forEach(ball => { 
                         if (ball.active) {
                             ball.x = clamp(ball.x, PLAYABLE_RECT.left + BALL_RADIUS, PLAYABLE_RECT.right - BALL_RADIUS);
                             ball.y = clamp(ball.y, PLAYABLE_RECT.top + BALL_RADIUS, PLAYABLE_RECT.bottom - BALL_RADIUS);
                         }
                    }); 
                }
             }
        }
        function resetToStartPositions() {
            gameState = 'aiming';
            document.body.classList.remove('aim-locked'); // <-- Asegurar que se quite el bloqueo
            if (!PLAYABLE_RECT.width || PLAYABLE_RECT.width <= 0) { return; }
            cueBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.25; cueBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
            blackBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.7; blackBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            blackBall.vx = 0; blackBall.vy = 0; blackBall.active = true;
            balls = [cueBall, blackBall];
            lastCueBallPos = null; lastBlackBallPos = null; wasLastBlackBallActive = true;
            spinEffect.x = 0; spinEffect.y = 0;
            if (spinBallControl.x) { spinIndicator.x = spinBallControl.x; spinIndicator.y = spinBallControl.y; drawSpinControl(); }
        }
        function restoreLastPositions() {
             if (!lastCueBallPos || !lastBlackBallPos) { resetToStartPositions(); return; }
             gameState = 'aiming';
             document.body.classList.remove('aim-locked'); // <-- Asegurar que se quite el bloqueo
             cueBall.x = lastCueBallPos.x; cueBall.y = lastCueBallPos.y;
             cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
             blackBall.x = lastBlackBallPos.x; blackBall.y = lastBlackBallPos.y;
             blackBall.vx = 0; blackBall.vy = 0; blackBall.active = wasLastBlackBallActive;
             balls = [cueBall, blackBall];
             spinEffect.x = 0; spinEffect.y = 0;
             if (spinBallControl.x) { spinIndicator.x = spinBallControl.x; spinIndicator.y = spinBallControl.y; drawSpinControl(); }
        }

        // --- 5. FUNCIONES DE DIBUJO ---
        function drawTable() {
             if (!TABLE_WIDTH || TABLE_WIDTH <= 0 || !isFinite(TABLE_WIDTH) || !isFinite(TABLE_HEIGHT)) { return; }
             if (!PLAYABLE_RECT.width || !PLAYABLE_RECT.height || PLAYABLE_RECT.width <= 0 || PLAYABLE_RECT.height <= 0) { return; }

             ctx.clearRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
             
             // 1. Madera
             const woodGradient = ctx.createLinearGradient(0, 0, 0, TABLE_HEIGHT);
             woodGradient.addColorStop(0, '#6b2112'); 
             woodGradient.addColorStop(0.5, '#a1331d'); 
             woodGradient.addColorStop(1, '#6b2112');
             ctx.fillStyle = woodGradient; 
             ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
             
             // 2. Diamantes
             const diamondRadius = CUSHION_SIZE * 0.18; 
             const playableWidth = PLAYABLE_RECT.width; 
             const playableHeight = PLAYABLE_RECT.height;
             const segmentX = playableWidth / 8; 
             const segmentY = playableHeight / 4;
             const topRailY = PLAYABLE_RECT.top / 2; 
             const bottomRailY = PLAYABLE_RECT.bottom + CUSHION_SIZE / 2;
             const leftRailX = PLAYABLE_RECT.left / 2; 
             const rightRailX = PLAYABLE_RECT.right + CUSHION_SIZE / 2;
             
             const drawDiamond = (x, y) => {
                 if (diamondRadius <= 0 || !isFinite(diamondRadius)) return;
                ctx.save(); 
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)'; 
                ctx.shadowBlur = 2; ctx.shadowOffsetY = 1;
                const grad = ctx.createRadialGradient(x, y - 1, 0, x, y, diamondRadius);
                grad.addColorStop(0, '#FFFFFF'); 
                grad.addColorStop(1, '#e0e0e0');
                ctx.fillStyle = grad; 
                ctx.beginPath(); 
                ctx.arc(x, y, diamondRadius, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.restore();
             };
             
             for (let i = 1; i <= 7; i++) { 
                 const x = PLAYABLE_RECT.left + (segmentX * i); 
                 drawDiamond(x, topRailY); 
                 drawDiamond(x, bottomRailY); 
             }
             for (let i = 1; i <= 3; i++) { 
                 const y = PLAYABLE_RECT.top + (segmentY * i); 
                 drawDiamond(leftRailX, y); 
                 drawDiamond(rightRailX, y); 
             }
             
             // 3. Fieltro verde
             ctx.fillStyle = '#059669'; 
             ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
             
             // Línea de Salida
             const baulkLineX = PLAYABLE_RECT.left + (segmentX * 2); 
             const headSpotY = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
             ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.fillStyle = 'rgba(255, 255, 255, 0.25)'; ctx.lineWidth = 1;
             ctx.beginPath(); ctx.moveTo(baulkLineX, PLAYABLE_RECT.top); ctx.lineTo(baulkLineX, PLAYABLE_RECT.bottom); ctx.stroke();
             ctx.beginPath(); ctx.arc(baulkLineX, headSpotY, (BALL_RADIUS || 5) * 0.2, 0, Math.PI * 2); ctx.fill();
             
             // Sombra interior
             ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 8;
             ctx.beginPath(); ctx.rect(0, 0, TABLE_WIDTH, TABLE_HEIGHT); ctx.rect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
             ctx.clip('evenodd'); ctx.fillRect(PLAYABLE_RECT.left - 10, PLAYABLE_RECT.top - 10, PLAYABLE_RECT.width + 20, PLAYABLE_RECT.height + 20); ctx.restore();
             
             // Buchacas
             POCKETS.forEach(pocket => {
                 if (typeof pocket.x !== 'number' || typeof pocket.y !== 'number' || POCKET_RADIUS <= 0 || !isFinite(POCKET_RADIUS)) return;
                const grad = ctx.createRadialGradient(pocket.x, pocket.y, POCKET_RADIUS * 0.5, pocket.x, pocket.y, POCKET_RADIUS);
                grad.addColorStop(0, '#111111'); 
                grad.addColorStop(1, '#000000');
                ctx.fillStyle = grad; 
                ctx.beginPath(); 
                ctx.arc(pocket.x, pocket.y, POCKET_RADIUS, 0, Math.PI * 2); 
                ctx.fill();
             });
        }
        function drawBall(ball, color) {
            if (typeof ball.x !== 'number' || typeof ball.y !== 'number' || !BALL_RADIUS || BALL_RADIUS <= 0 || !isFinite(BALL_RADIUS)) return;
            
            // Sombra
            ctx.save(); 
            ctx.beginPath(); 
            ctx.arc(ball.x + BALL_RADIUS * 0.1, ball.y + BALL_RADIUS * 0.15, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'; 
            ctx.shadowBlur = BALL_RADIUS * 0.3; 
            ctx.shadowOffsetY = BALL_RADIUS * 0.1; 
            ctx.fill(); 
            ctx.restore();
            
            // Bola
            ctx.beginPath(); 
            const hX = ball.x - BALL_RADIUS * 0.3, hY = ball.y - BALL_RADIUS * 0.4;
            const grad = ctx.createRadialGradient(hX, hY, BALL_RADIUS * 0.05, ball.x, ball.y, BALL_RADIUS);
            if (color === '#FFFFFF') { 
                grad.addColorStop(0, '#FFFFFF'); 
                grad.addColorStop(0.7, '#f0f0f0'); 
                grad.addColorStop(1, '#cccccc'); 
            }
            else { 
                grad.addColorStop(0, '#666666'); 
                grad.addColorStop(0.7, '#2a2a2a'); 
                grad.addColorStop(1, '#000000'); 
            }
            ctx.fillStyle = grad; 
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2); 
            ctx.fill();
        }
        function drawBlackBall() {
            if (typeof blackBall.x !== 'number' || typeof blackBall.y !== 'number' || !BALL_RADIUS || BALL_RADIUS <= 0 || !isFinite(BALL_RADIUS)) return;
            
            drawBall(blackBall, '#000000'); 
            
            const circR = BALL_RADIUS * 0.5;
             if (circR <= 0 || !isFinite(circR)) return;
            
            // Círculo blanco
            ctx.beginPath(); 
            ctx.arc(blackBall.x, blackBall.y, circR, 0, Math.PI * 2); 
            ctx.fillStyle = '#FFFFFF'; 
            ctx.fill();
            
            // Número 8
            ctx.fillStyle = '#000000'; 
            const fontS = circR * 1.5; 
            if (fontS <= 0 || !isFinite(fontS)) return;
            ctx.font = `bold ${fontS}px Arial`; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle'; 
            ctx.fillText('8', blackBall.x, blackBall.y + BALL_RADIUS * 0.05);
        }
        function drawSpinControl() {
            if (!canvasSpin || canvasSpin.width === 0 || canvasSpin.height === 0 || !spinBallControl.radius || !isFinite(spinBallControl.radius) || spinBallControl.radius <= 0) return;
            
            ctxSpin.clearRect(0, 0, canvasSpin.width, canvasSpin.height);
            
            // Sombra
            ctxSpin.save(); 
            ctxSpin.beginPath(); 
            ctxSpin.arc(spinBallControl.x + 1, spinBallControl.y + 2, spinBallControl.radius, 0, Math.PI * 2);
            ctxSpin.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctxSpin.shadowColor = 'rgba(0, 0, 0, 0.2)'; 
            ctxSpin.shadowBlur = 3; 
            ctxSpin.shadowOffsetY = 1; 
            ctxSpin.fill(); 
            ctxSpin.restore();
            
            // Bola
            ctxSpin.beginPath(); 
            const hX = spinBallControl.x - spinBallControl.radius * 0.3, hY = spinBallControl.y - spinBallControl.radius * 0.4;
            const grad = ctxSpin.createRadialGradient(hX, hY, spinBallControl.radius * 0.05, spinBallControl.x, spinBallControl.y, spinBallControl.radius);
            grad.addColorStop(0, '#FFFFFF'); 
            grad.addColorStop(0.7, '#f0f0f0'); 
            grad.addColorStop(1, '#cccccc');
            ctxSpin.fillStyle = grad; 
            ctxSpin.arc(spinBallControl.x, spinBallControl.y, spinBallControl.radius, 0, Math.PI * 2); 
            ctxSpin.fill();
            
            // Indicador de efecto
             const indR = spinBallControl.radius * 0.12; 
             if (indR <= 0 || !isFinite(indR)) return;
            ctxSpin.beginPath(); 
            ctxSpin.arc(spinIndicator.x, spinIndicator.y, indR, 0, Math.PI * 2);
            ctxSpin.fillStyle = 'rgba(220, 38, 38, 0.9)'; 
            ctxSpin.strokeStyle = 'rgba(127, 29, 29, 0.9)'; 
            ctxSpin.lineWidth = 1; 
            ctxSpin.fill(); 
            ctxSpin.stroke();
        }

        // --- 6. LÓGICA DE TRAYECTORIA Y GOLPE ---
        function findWallCollision(startPos, dir) {
            let tMin = Infinity; 
            let hitType = null;
            
            if (!BALL_RADIUS || BALL_RADIUS <= 0 || !isFinite(BALL_RADIUS) || !PLAYABLE_RECT.width || PLAYABLE_RECT.width <= 0) {
                return { t: Infinity, hitType: null };
            }

            if (dir.x > 0.001) { 
                let t = (PLAYABLE_RECT.right - BALL_RADIUS - startPos.x) / dir.x; 
                if (t > 0 && t < tMin) { tMin = t; hitType = 'right'; } 
            }
            else if (dir.x < -0.001) { 
                let t = (PLAYABLE_RECT.left + BALL_RADIUS - startPos.x) / dir.x; 
                if (t > 0 && t < tMin) { tMin = t; hitType = 'left'; } 
            }
            
            if (dir.y > 0.001) { 
                let t = (PLAYABLE_RECT.bottom - BALL_RADIUS - startPos.y) / dir.y; 
                if (t > 0 && t < tMin) { tMin = t; hitType = 'bottom'; } 
            }
            else if (dir.y < -0.001) { 
                let t = (PLAYABLE_RECT.top + BALL_RADIUS - startPos.y) / dir.y; 
                if (t > 0 && t < tMin) { tMin = t; hitType = 'top'; } 
            }
            
            return { t: tMin, hitType: hitType };
        }
        function findBallCollision(startPos, dir, targetBall) {
            if (!BALL_RADIUS || BALL_RADIUS <= 0 || !isFinite(BALL_RADIUS) || typeof targetBall?.x !== 'number' || typeof targetBall?.y !== 'number') {
                return { t: Infinity };
            }
            
            const collisionRadius = BALL_RADIUS * 2; 
            const v = { x: targetBall.x - startPos.x, y: targetBall.y - startPos.y };
            
            const dirMagSq = dir.x * dir.x + dir.y * dir.y; 
            if (dirMagSq < 0.0001) return { t: Infinity }; 
            
            const dotProd = v.x * dir.x + v.y * dir.y; 
            if (dotProd <= 0) return { t: Infinity }; 
            
            const vMagSq = v.x * v.x + v.y * v.y; 
            const t_closest = dotProd / dirMagSq;
            
            const distSq_line_center = vMagSq - (dotProd * dotProd) / dirMagSq; 
            const collisionRadiusSqr = collisionRadius * collisionRadius;
            
            if (distSq_line_center >= collisionRadiusSqr) return { t: Infinity }; 
            
            const thc_sq = collisionRadiusSqr - distSq_line_center; 
            if (thc_sq < 0) return { t: Infinity}; 
            
            const thc = Math.sqrt(thc_sq); 
            const dirMag = Math.sqrt(dirMagSq); 
            const t_hit = t_closest - thc / dirMag;
            
            if (t_hit < 0) return { t: Infinity }; 
            
            return { t: t_hit * dirMag };
        }


        function drawFullTrajectory() {
            // --- INICIO CAMBIO: Dibujar línea también si está bloqueado ---
            if ((gameState !== 'aiming' && gameState !== 'aimLocked') || !cueBall.active) return;
            // --- FIN CAMBIO ---
            if (!TABLE_WIDTH || TABLE_WIDTH <= 0) return;

            let startPos = { x: cueBall.x, y: cueBall.y }; 
            let dir = aimDir;
            let normalizedDir = { ...dir }; 
            const magAim = Math.hypot(dir.x, dir.y);
            if (magAim < 0.01) return; 
            normalizedDir.x /= magAim; normalizedDir.y /= magAim;

            const wallHit = findWallCollision(startPos, normalizedDir); 
            const ballHit = blackBall.active ? findBallCollision(startPos, normalizedDir, blackBall) : { t: Infinity };

            let firstHitTime = Math.min(wallHit?.t ?? Infinity, ballHit?.t ?? Infinity);

            if (firstHitTime === Infinity || firstHitTime > TABLE_WIDTH * 2 || !isFinite(firstHitTime)) { 
                firstHitTime = TABLE_WIDTH * 2;
            }
            
            const firstHitPoint = { 
                x: startPos.x + normalizedDir.x * firstHitTime, 
                y: startPos.y + normalizedDir.y * firstHitTime 
            };
            
            ctx.beginPath(); 
            ctx.moveTo(startPos.x, startPos.y); 
            ctx.lineTo(firstHitPoint.x, firstHitPoint.y);
            
            // --- INICIO CAMBIO: Estilo de Línea (Bloqueado) ---
            if (gameState === 'aimLocked') {
                ctx.strokeStyle = 'rgba(255, 255, 255, 1)'; // Sólido y brillante
                ctx.setLineDash([]);
            } else {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; // Punteado
                ctx.setLineDash([4, 4]);
            }
            ctx.lineWidth = 1.5; 
            ctx.stroke();
            // --- FIN CAMBIO ---

            if (ballHit.t <= wallHit.t && blackBall.active) {
                const cueHitPoint = firstHitPoint;
                
                let blackBallDir = { x: blackBall.x - cueHitPoint.x, y: blackBall.y - cueHitPoint.y }; 
                const blackMag = Math.hypot(blackBallDir.x, blackBallDir.y);
                if (blackMag > 0.01) { 
                    blackBallDir.x /= blackMag; 
                    blackBallDir.y /= blackMag; 
                    drawPath(blackBall, blackBallDir, 'rgba(255, 255, 0, 0.6)', 3); // Línea de la bola 8 (amarilla)
                }
                
                const normalDir = { ...blackBallDir }; 
                let tangentDir = { x: -normalDir.y, y: normalDir.x }; 
                
                const check = normalizedDir.x * tangentDir.x + normalizedDir.y * tangentDir.y; 
                if (check < 0) { 
                    tangentDir.x *= -1; 
                    tangentDir.y *= -1; 
                }
                
                const proj_n = normalizedDir.x * normalDir.x + normalizedDir.y * normalDir.y; 
                const proj_t = normalizedDir.x * tangentDir.x + normalizedDir.y * tangentDir.y;
                
                const stun = 1 - Math.abs(spinEffect.y), 
                      follow = spinEffect.y < 0 ? -spinEffect.y : 0, 
                      draw = spinEffect.y > 0 ? spinEffect.y : 0; 
                
                const new_proj_n = proj_n * (follow - draw) + 0 * stun; 
                const new_proj_t = proj_t; 
                
                let cueAfterDir = { 
                    x: normalDir.x * new_proj_n + tangentDir.x * new_proj_t, 
                    y: normalDir.y * new_proj_n + tangentDir.y * new_proj_t 
                }; 
                
                const cueAfterMag = Math.hypot(cueAfterDir.x, cueAfterDir.y);
                if (cueAfterMag > 0.01 && BALL_RADIUS > 0) { 
                    cueAfterDir.x /= cueAfterMag; 
                    cueAfterDir.y /= cueAfterMag; 
                    const start = { 
                        x: cueHitPoint.x - normalDir.x * BALL_RADIUS, 
                        y: cueHitPoint.y - normalDir.y * BALL_RADIUS 
                    };
                    if (isFinite(start.x) && isFinite(start.y)) {
                        drawPath(start, cueAfterDir, 'rgba(255, 165, 0, 0.6)', 3, { x: spinEffect.x, y: 0 }); // Línea de efecto (naranja)
                    }
                }
                
            } else if (wallHit.t !== Infinity && isFinite(wallHit.t)) {
                // ... (lógica de predicción de golpe a banda, ya se maneja en drawPath) ...
                let nextDir = { ...normalizedDir };
                let nextSpin = { ...spinEffect };
                
                if (wallHit.hitType === 'left' || wallHit.hitType === 'right') {
                    nextDir.x *= -1;
                    nextDir.y += nextSpin.x * SPIN_FACTOR_CUSHION * (wallHit.hitType === 'right' ? -1 : 1) * Math.sign(nextDir.y || 1);
                }
                if (wallHit.hitType === 'top' || wallHit.hitType === 'bottom') {
                    nextDir.y *= -1;
                    nextDir.x += nextSpin.x * SPIN_FACTOR_CUSHION * (wallHit.hitType === 'bottom' ? 1 : -1) * Math.sign(nextDir.x || 1);
                }
                
                nextSpin.x *= 0.8; 
                
                const nextMag = Math.hypot(nextDir.x, nextDir.y); 
                if (nextMag > 0.01) { 
                    nextDir.x /= nextMag; 
                    nextDir.y /= nextMag; 
                    drawPath(firstHitPoint, nextDir, 'rgba(255, 255, 255, 0.6)', 3, nextSpin); // Línea de rebote (blanca)
                }
            } 
            ctx.setLineDash([]); // Asegurarse de resetear el dash
        }

        function drawPath(startPos, dir, color, maxBounces = 3, spin = {x: 0, y: 0}) {
            if (!startPos || typeof startPos.x !== 'number' || typeof startPos.y !== 'number' || !isFinite(startPos.x) || !isFinite(startPos.y)) return;
            if (!dir || typeof dir.x !== 'number' || typeof dir.y !== 'number' || !isFinite(dir.x) || !isFinite(dir.y)) return;
            if (!POCKET_RADIUS || POCKET_RADIUS <= 0) return;
            
            let currentPos = { ...startPos }; 
            let currentDir = { ...dir };
            let currentSpin = { ...spin }; 

            ctx.beginPath(); 
            ctx.moveTo(currentPos.x, currentPos.y); 
            ctx.strokeStyle = color; 
            ctx.lineWidth = 1.5; 
            
            // --- INICIO CAMBIO: Estilo de Línea (Bloqueado) ---
            if (gameState === 'aimLocked') {
                ctx.setLineDash([]);
                // Hacer el color más brillante si está bloqueado
                if (color.includes('0.6')) { // Solo ajustar las líneas de predicción
                     ctx.strokeStyle = color.replace('0.6', '1');
                }
            } else {
                ctx.setLineDash([4, 4]);
            }
            // --- FIN CAMBIO ---
            
            for (let i = 0; i < maxBounces; i++) {
                const wallHit = findWallCollision(currentPos, currentDir); 
                const ballHit = (color !== 'rgba(255, 255, 0, 0.6)' && blackBall.active) ? findBallCollision(currentPos, currentDir, blackBall) : { t: Infinity }; 
                let hitTime = Math.min(wallHit?.t ?? Infinity, ballHit?.t ?? Infinity);
                
                if (hitTime === Infinity || hitTime < 0.1 || !isFinite(hitTime)) break;
                
                const hitPoint = { 
                    x: currentPos.x + currentDir.x * hitTime, 
                    y: currentPos.y + currentDir.y * hitTime 
                }; 
                
                if (!isFinite(hitPoint.x) || !isFinite(hitPoint.y)) break; 
                
                ctx.lineTo(hitPoint.x, hitPoint.y);
                
                if (ballHit.t <= wallHit.t) break; 
                
                let isPocketed = false; 
                for (const pocket of POCKETS) { 
                    if (Math.hypot(hitPoint.x - pocket.x, hitPoint.y - pocket.y) < POCKET_RADIUS * 0.9) { 
                        isPocketed = true; 
                        break; 
                    } 
                } 
                if (isPocketed) break; 
                
                currentPos = hitPoint;
                
                if (wallHit.hitType === 'left' || wallHit.hitType === 'right') {
                    currentDir.x *= -1;
                    currentDir.y += currentSpin.x * SPIN_FACTOR_CUSHION * (wallHit.hitType === 'right' ? -1 : 1) * Math.sign(currentDir.y || 1);
                }
                if (wallHit.hitType === 'top' || wallHit.hitType === 'bottom') {
                    currentDir.y *= -1;
                    currentDir.x += currentSpin.x * SPIN_FACTOR_CUSHION * (wallHit.hitType === 'bottom' ? 1 : -1) * Math.sign(currentDir.x || 1);
                }
                
                currentSpin.x *= 0.8; 
                
                const mag = Math.hypot(currentDir.x, currentDir.y); 
                if (mag > 0.01 && isFinite(mag)) { 
                    currentDir.x /= mag; 
                    currentDir.y /= mag; 
                } else {
                    break; 
                }
            } 
            ctx.stroke();
        }


         function drawPoolCue() {
             if (!cueBall.active || !BALL_RADIUS || BALL_RADIUS <= 0) return;
             if (!TABLE_WIDTH || TABLE_WIDTH <=0) return;
             
             const angle = Math.atan2(aimDir.y, aimDir.x);
             
             let pullBack = 0;
             if (powerBar) { 
                 const powerValue = parseInt(powerBar.value);
                 const maxPull = (TABLE_WIDTH || 500) * 0.20;
                 if (isFinite(powerValue) && isFinite(maxPull)) {
                     pullBack = maxPull * (powerValue / 100);
                 }
             }
             
             ctx.save(); 
             ctx.translate(cueBall.x, cueBall.y); 
             ctx.rotate(angle);
             
             const cueStartX = -BALL_RADIUS * 1.5 - pullBack; 
             const cueLength = TABLE_WIDTH * 0.5; 
             const cueTipWidth = BALL_RADIUS * 0.12; 
             const cueButtWidth = BALL_RADIUS * 0.30;

             if (!isFinite(cueStartX) || !isFinite(cueLength) || cueTipWidth <= 0) { 
                 ctx.restore(); return; 
             }
             
             ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; ctx.shadowBlur = 6; ctx.shadowOffsetY = 2;
             
             const gripLength = cueLength * 0.3; 
             if (!isFinite(gripLength)) { ctx.restore(); return; }
             
             // Mango
             ctx.beginPath(); 
             ctx.moveTo(cueStartX - cueLength, -cueButtWidth); 
             ctx.lineTo(cueStartX - cueLength + gripLength, -cueButtWidth * 0.8); 
             ctx.lineTo(cueStartX - cueLength + gripLength, cueButtWidth * 0.8); 
             ctx.lineTo(cueStartX - cueLength, cueButtWidth); 
             ctx.closePath(); ctx.fillStyle = '#2d221c'; ctx.fill();
             
             // Parte delantera
             ctx.beginPath(); 
             ctx.moveTo(cueStartX - cueLength + gripLength, -cueButtWidth * 0.8); 
             ctx.lineTo(cueStartX, -cueTipWidth); 
             ctx.lineTo(cueStartX, cueTipWidth); 
             ctx.lineTo(cueStartX - cueLength + gripLength, cueButtWidth * 0.8); 
             ctx.closePath(); 
             const woodGradient = ctx.createLinearGradient(cueStartX - cueLength, 0, cueStartX, 0); 
             woodGradient.addColorStop(0, '#e8c99b'); woodGradient.addColorStop(1, '#d1ae74'); 
             ctx.fillStyle = woodGradient; ctx.fill();
             
             // Virola y Punta
             ctx.fillStyle = '#f0f0f0'; ctx.fillRect(cueStartX, -cueTipWidth, BALL_RADIUS * 0.2, cueTipWidth * 2);
             ctx.fillStyle = '#5c3a3a'; ctx.fillRect(cueStartX + BALL_RADIUS * 0.2, -cueTipWidth, BALL_RADIUS * 0.1, cueTipWidth * 2);
             
             ctx.restore();
         }
         
         function drawGhostBall() {
             if (gameState !== 'aiming' || draggingBall || !mousePos?.x) return; // No mostrar si la mira está bloqueada o arrastrando
             if (!BALL_RADIUS || BALL_RADIUS <= 0 || !isFinite(BALL_RADIUS)) return;
             
             ctx.save(); 
             ctx.globalAlpha = 0.4; 
             ctx.beginPath(); 
             ctx.arc(mousePos.x, mousePos.y, BALL_RADIUS, 0, Math.PI * 2);
             
             const grad = ctx.createRadialGradient( 
                 mousePos.x - BALL_RADIUS * 0.3, 
                 mousePos.y - BALL_RADIUS * 0.4, 
                 BALL_RADIUS * 0.05, 
                 mousePos.x, 
                 mousePos.y, 
                 BALL_RADIUS 
             );
             grad.addColorStop(0, 'rgba(255, 255, 255, 0.5)'); 
             grad.addColorStop(1, 'rgba(200, 200, 200, 0.3)');
             
             ctx.fillStyle = grad; 
             ctx.fill(); 
             ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; 
             ctx.lineWidth = 1; 
             ctx.stroke(); 
             ctx.restore();
         }

        // --- 7. MOTOR DE FÍSICA (SIMULACIÓN) ---
        function updatePhysics() {
            if (gameState !== 'simulating') return;
            
            let ballsStillMoving = false;
            
            // 1. Mover bolas y aplicar fricción
            for (const ball of balls) { 
                if (!ball.active) continue; 
                ball.vx *= FRICTION; 
                ball.vy *= FRICTION; 
                if (Math.hypot(ball.vx, ball.vy) < MIN_SPEED) { 
                    ball.vx = 0; ball.vy = 0; 
                } else { 
                    ball.x += ball.vx; 
                    ball.y += ball.vy; 
                    ballsStillMoving = true; 
                } 
            }
            
            // 2. Colisiones con bandas y troneras
            for (const ball of balls) {
                if (!ball.active || (ball.vx === 0 && ball.vy === 0)) continue; 
                
                if (!BALL_RADIUS || BALL_RADIUS <= 0 || !POCKET_RADIUS || POCKET_RADIUS <= 0 || !PLAYABLE_RECT.left || !isFinite(BALL_RADIUS)) continue;
                
                // A. Comprobar Buchacas
                let isPocketed = false; 
                for (const pocket of POCKETS) { 
                    if (typeof pocket.x !== 'number' || typeof pocket.y !== 'number' || !isFinite(pocket.x) || !isFinite(pocket.y)) continue; 
                    
                    if (Math.hypot(ball.x - pocket.x, ball.y - pocket.y) < POCKET_RADIUS * 0.9) { 
                        ball.active = false; 
                        ball.vx = 0; 
                        ball.vy = 0; 
                        isPocketed = true; 
                        
                        if (soundsReady) {
                            try { pocketSound.triggerAttackRelease("16n"); } catch(e) {}
                        }
                        
                        setTimeout(() => { 
                            requestAnimationFrame(() => { 
                                if (!PLAYABLE_RECT.width || PLAYABLE_RECT.width <= 0) return; 
                                
                                if (ball === cueBall) { 
                                    ball.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.25; 
                                    ball.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2; 
                                } else { 
                                    ball.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.7; 
                                    ball.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2; 
                                } 
                                ball.active = true; 
                            }); 
                        }, 500); 
                        
                        break; 
                    } 
                } 
                
                // B. Comprobar Bandas
                if (!isPocketed) {
                    let hit = false; 
                    
                    if (!PLAYABLE_RECT.left || !isFinite(PLAYABLE_RECT.left) || typeof spinEffect.x !== 'number' || !isFinite(spinEffect.x)) continue;
                    
                    const speed = Math.hypot(ball.vx, ball.vy); 
                    let dir_x = 0;
                    let dir_y = 0;
                    if (speed > 0.01) {
                        dir_x = ball.vx / speed;
                        dir_y = ball.vy / speed;
                    }

                    let hitType = null;

                    if (ball.x + BALL_RADIUS > PLAYABLE_RECT.right && ball.vx > 0) { // Hit Right
                        ball.x = PLAYABLE_RECT.right - BALL_RADIUS; 
                        dir_x *= -1; 
                        if (ball === cueBall) dir_y += spinEffect.x * SPIN_FACTOR_CUSHION * -Math.sign(dir_y || 1);
                        hit = true; hitType = 'right';
                    }
                    else if (ball.x - BALL_RADIUS < PLAYABLE_RECT.left && ball.vx < 0) { // Hit Left
                        ball.x = PLAYABLE_RECT.left + BALL_RADIUS; 
                        dir_x *= -1;
                        if (ball === cueBall) dir_y += spinEffect.x * SPIN_FACTOR_CUSHION * Math.sign(dir_y || 1);
                        hit = true; hitType = 'left';
                    }
                    if (ball.y + BALL_RADIUS > PLAYABLE_RECT.bottom && ball.vy > 0) { // Hit Bottom
                        ball.y = PLAYABLE_RECT.bottom - BALL_RADIUS; 
                        dir_y *= -1;
                        if (ball === cueBall) dir_x += spinEffect.x * SPIN_FACTOR_CUSHION * Math.sign(dir_x || 1);
                        hit = true; hitType = 'bottom';
                    }
                    else if (ball.y - BALL_RADIUS < PLAYABLE_RECT.top && ball.vy < 0) { // Hit Top
                        ball.y = PLAYABLE_RECT.top + BALL_RADIUS; 
                        dir_y *= -1;
                        if (ball === cueBall) dir_x += spinEffect.x * SPIN_FACTOR_CUSHION * -Math.sign(dir_x || 1);
                        hit = true; hitType = 'top';
                    }

                    if (hit) { 
                        const finalSpeed = speed * RESTITUTION; 
                        
                        const newMag = Math.hypot(dir_x, dir_y);
                        if (newMag > 0.01 && isFinite(newMag) && isFinite(finalSpeed)) {
                            ball.vx = (dir_x / newMag) * finalSpeed;
                            ball.vy = (dir_y / newMag) * finalSpeed;
                        } else {
                            if (hitType === 'left' || hitType === 'right') ball.vx *= -RESTITUTION;
                            if (hitType === 'top' || hitType === 'bottom') ball.vy *= -RESTITUTION;
                        }

                        if (ball === cueBall) {
                            spinEffect.y *= 0.5; 
                            spinEffect.x *= 0.8; 
                        }
                        
                        if (soundsReady) { 
                            try {
                                const v = Math.min(speed / 8, 1); 
                                cushionHitSound.triggerAttackRelease("C2", "16n", Tone.now(), v * 0.7); 
                            } catch(e) {}
                        } 
                    }
                }
            }
            
            // 3. Colisiones entre bolas
            if (cueBall.active && blackBall.active && BALL_RADIUS > 0 && isFinite(BALL_RADIUS)) {
                const dx = blackBall.x - cueBall.x; 
                const dy = blackBall.y - cueBall.y; 
                if (!isFinite(dx) || !isFinite(dy)) return; 
                
                const dist = Math.hypot(dx, dy); 
                const collisionDist = BALL_RADIUS * 2; 
                if (!isFinite(dist) || dist <= 0) return; 
                
                if (dist < collisionDist) {
                    const relVel = Math.hypot(cueBall.vx - blackBall.vx, cueBall.vy - blackBall.vy); 
                    if (!isFinite(relVel)) return; 
                    
                    if (soundsReady) { 
                        try {
                            const v = Math.min(relVel / 12, 1); 
                            ballCollisionSound.triggerAttackRelease("G4", "16n", Tone.now(), v); 
                        } catch(e) {}
                    }
                    
                    const nx = dx / dist, ny = dy / dist, tx = -ny, ty = nx; 
                    if (!isFinite(nx) || !isFinite(ny) || !isFinite(tx) || !isFinite(ty)) return;
                    
                    const v1n = cueBall.vx * nx + cueBall.vy * ny, 
                          v1t = cueBall.vx * tx + cueBall.vy * ty; 
                    const v2n = blackBall.vx * nx + blackBall.vy * ny, 
                          v2t = blackBall.vx * tx + blackBall.vy * ty; 
                          
                    if (!isFinite(v1n) || !isFinite(v1t) || !isFinite(v2n) || !isFinite(v2t)) return;
                    
                    const v1n_f = v2n, v2n_f = v1n; 
                    
                    const spinY = typeof spinEffect.y === 'number' && isFinite(spinEffect.y) ? spinEffect.y : 0;
                    const stun = 1 - Math.abs(spinY), 
                          follow = spinY < 0 ? -spinY : 0, 
                          draw = spinY > 0 ? spinY : 0; 
                          
                    if (!isFinite(stun) || !isFinite(follow) || !isFinite(draw)) return;
                    
                    const v1n_f_spin = v1n * (follow - draw) + v1n_f * stun; 
                    if (!isFinite(v1n_f_spin)) return;
                    
                    const newCueVx = v1n_f_spin * nx + v1t * tx; 
                    const newCueVy = v1n_f_spin * ny + v1t * ty; 
                    const newBlackVx = v2n_f * nx + v2t * tx; 
                    const newBlackVy = v2n_f * ny + v2t * ty;
                    
                    if (isFinite(newCueVx) && isFinite(newCueVy) && isFinite(newBlackVx) && isFinite(newBlackVy)) { 
                        cueBall.vx = newCueVx; 
                        cueBall.vy = newCueVy; 
                        blackBall.vx = newBlackVx; 
                        blackBall.vy = newBlackVy; 
                    } else { 
                        console.warn("Non-finite velocity calc in ball collision."); 
                        cueBall.vx *= 0.5; cueBall.vy *= 0.5; blackBall.vx *= 0.5; blackBall.vy *= 0.5; 
                    }
                    
                    const overlap = collisionDist - dist + 0.01; 
                    const sepFactor = 0.5; 
                    if (isFinite(overlap)) { 
                        cueBall.x -= overlap * nx * sepFactor; 
                        cueBall.y -= overlap * ny * sepFactor; 
                        blackBall.x += overlap * nx * sepFactor; 
                        blackBall.y += overlap * ny * sepFactor; 
                    } 
                    
                    spinEffect.y = 0; 
                }
            } 
            
            if (!ballsStillMoving && gameState === 'simulating') { 
                setTimeout(() => { 
                    const stillStopped = balls.every(b => !b.active || (b.vx === 0 && b.vy === 0)); 
                    if (stillStopped && gameState === 'simulating') {
                        gameState = 'aiming'; // Regresar a 'aiming' (desbloqueado)
                        document.body.classList.remove('aim-locked'); // Quitar clase CSS
                    }
                }, 100); 
            }
        }


        // --- 8. BUCLE PRINCIPAL DE ANIMACIÓN ---
        function gameLoop() {
             if (canvas.width <= 0 || canvas.height <= 0) {
                 setupCanvas(); 
                 requestAnimationFrame(gameLoop); 
                 return;
             }
             
             if (gameState === 'simulating') { 
                 updatePhysics(); 
             }
             
             drawTable();
             
             // --- INICIO CAMBIO: Dibujar UI en 'aiming' y 'aimLocked' ---
             if (gameState === 'aiming' || gameState === 'aimLocked') {
                 drawFullTrajectory(); 
                 drawPoolCue(); 
                 drawGhostBall(); // La bola fantasma se oculta sola si gameState no es 'aiming'
             }
             // --- FIN CAMBIO ---
             
             if (cueBall.active && isFinite(cueBall.x)) drawBall(cueBall, '#FFFFFF');
             if (blackBall.active && isFinite(blackBall.x)) drawBlackBall();
             
             requestAnimationFrame(gameLoop);
        }

        // --- 9. MANEJADORES DE EVENTOS ---
        function getPosInCanvas(event, targetCanvas) {
             if (!targetCanvas) return null; 
             const rect = targetCanvas.getBoundingClientRect(); 
             
             if (rect.width === 0 || rect.height === 0 || targetCanvas.width === 0 || targetCanvas.height === 0) 
                return null; 
             
             const scaleX = targetCanvas.width / rect.width; 
             const scaleY = targetCanvas.height / rect.height; 
             
             let clientX, clientY; 
             
             if (event.touches && event.touches.length > 0) { 
                 clientX = event.touches[0].clientX; 
                 clientY = event.touches[0].clientY; 
             } else if (event.clientX !== undefined && event.clientY !== undefined) { 
                 clientX = event.clientX; 
                 clientY = event.clientY; 
             } else { 
                 return null; 
             } 
             
             if (typeof clientX !== 'number' || typeof clientY !== 'number' || !isFinite(clientX) || !isFinite(clientY)) {
                 return null; 
             }
             
             return { 
                 x: (clientX - rect.left) * scaleX, 
                 y: (clientY - rect.top) * scaleY 
             };
        }
        function clamp(value, min, max) { 
            return Math.max(min, Math.min(value, max)); 
        }


        function handleTableInteractionStart(event) {
             startAudioContext(); 
             if (gameState === 'simulating') return; 
             const pos = getPosInCanvas(event, canvas); 
             if (!pos) return; 
             mousePos = pos;
             const currentBallRadius = BALL_RADIUS || 10;
             if (!isFinite(cueBall.x) || !isFinite(blackBall.x)) return;

             const grabRadius = currentBallRadius * 2; 
             const distCue = Math.hypot(pos.x - cueBall.x, pos.y - cueBall.y); 
             const distBlack = Math.hypot(pos.x - blackBall.x, pos.y - blackBall.y);

             // --- INICIO CAMBIO: Lógica de Bloqueo Diferenciada ---
             if (gameState === 'aiming') { 
                 if (cueBall.active && distCue < grabRadius) 
                     draggingBall = cueBall; 
                 else if (blackBall.active && distBlack < grabRadius) 
                     draggingBall = blackBall; 
                 else {
                     // Si NO es un dispositivo táctil, bloqueamos con clic
                     if (!isTouchDevice) {
                         gameState = 'aimLocked';
                         document.body.classList.add('aim-locked');
                         // Y actualizamos la mira a esta posición
                         if (!isFinite(cueBall.x) || !isFinite(cueBall.y)) return;
                         const dx = pos.x - cueBall.x, dy = pos.y - cueBall.y, mag = Math.hypot(dx, dy);
                         if (isFinite(mag) && mag > 0.1) { 
                             aimDir.x = dx / mag; 
                             aimDir.y = dy / mag; 
                         }
                     }
                     // Si ES táctil, no hacemos nada aquí, el 'move' apunta
                 }
             } 
             else if (gameState === 'aimLocked') {
                 // Si ya está bloqueado, un clic desbloquea (en CUALQUIER dispositivo)
                 if (cueBall.active && distCue < grabRadius) 
                     draggingBall = cueBall; 
                 else if (blackBall.active && distBlack < grabRadius) 
                     draggingBall = blackBall;
                 else {
                     gameState = 'aiming';
                     document.body.classList.remove('aim-locked');
                 }
             } 
             // --- FIN CAMBIO ---
             
             if (!draggingBall && event.cancelable) {
                 event.preventDefault();
             } else if (draggingBall && event.cancelable) {
                 event.preventDefault();
             }
        }

        function handleGlobalInteractionEnd(event) {
             // --- INICIO CAMBIO: Lógica "Lift-to-Lock" para móvil ---
             if (isTouchDevice && !draggingBall && gameState === 'aiming') {
                 // Si es táctil, no estábamos arrastrando bola, y estábamos apuntando...
                 // ...bloqueamos la mira al levantar el dedo.
                 gameState = 'aimLocked';
                 document.body.classList.add('aim-locked');
             }
             // --- FIN CAMBIO ---

             if (draggingBall) { 
                 draggingBall = null; 
             }
             isSettingSpin = false;
        }

        function handleTableInteractionMove(event) {
             const pos = getPosInCanvas(event, canvas); 
             if (!pos) return; 
             mousePos = pos;
             const currentBallRadius = BALL_RADIUS || 10; 

             if (draggingBall && PLAYABLE_RECT.left) { 
                 draggingBall.x = clamp(pos.x, PLAYABLE_RECT.left + currentBallRadius, PLAYABLE_RECT.right - currentBallRadius); 
                 draggingBall.y = clamp(pos.y, PLAYABLE_RECT.top + currentBallRadius, PLAYABLE_RECT.bottom - currentBallRadius); 
                 if (event.cancelable) event.preventDefault(); 
             
             // --- INICIO CAMBIO: Lógica de Apuntado Diferenciada ---
             } else if (cueBall.active) { 
                 let canAim = false;
                 if (isTouchDevice) {
                     // En móvil, siempre apuntamos si estamos tocando la mesa y no arrastrando bola
                     canAim = true;
                     if (gameState === 'aimLocked') { // Si estaba bloqueado, el drag desbloquea
                         gameState = 'aiming';
                         document.body.classList.remove('aim-locked');
                     }
                 } else {
                     // En PC, solo apuntamos si el estado es 'aiming' (no bloqueado)
                     canAim = (gameState === 'aiming');
                 }

                 if (canAim) {
                     if (!isFinite(cueBall.x) || !isFinite(cueBall.y)) return;
                     const dx = pos.x - cueBall.x, dy = pos.y - cueBall.y, mag = Math.hypot(dx, dy);
                     if (isFinite(mag) && mag > 0.1) { 
                         aimDir.x = dx / mag; 
                         aimDir.y = dy / mag; 
                     }
                     if (event.type === 'touchmove' && event.cancelable) {
                         event.preventDefault();
                     }
                 }
             }
             // --- FIN CAMBIO ---
        }

        function updateSpin(pos) {
             if (!pos || !spinBallControl.radius || !isFinite(spinBallControl.radius) || spinBallControl.radius <= 0) return;
             if (!isFinite(pos.x) || !isFinite(pos.y)) return;
             
             const dx = pos.x - spinBallControl.x, 
                   dy = pos.y - spinBallControl.y; 
             if (!isFinite(dx) || !isFinite(dy)) return;
             
             const dist = Math.hypot(dx, dy); 
             if (!isFinite(dist)) return;
             
             const maxDist = spinBallControl.radius * 0.8; 
             if (maxDist <= 0 || !isFinite(maxDist)) return;
             
             const clampedDist = Math.min(dist, maxDist); 
             if (!isFinite(clampedDist)) return;
             
             const angle = (dist > 0.1) ? Math.atan2(dy, dx) : 0; 
             if (!isFinite(angle)) return;
             
             spinIndicator.x = spinBallControl.x + Math.cos(angle) * clampedDist; 
             spinIndicator.y = spinBallControl.y + Math.sin(angle) * clampedDist;
             
             if (!isFinite(spinIndicator.x) || !isFinite(spinIndicator.y)) { 
                 spinIndicator.x = spinBallControl.x; 
                 spinIndicator.y = spinBallControl.y; 
             } 
             
             spinEffect.x = (spinIndicator.x - spinBallControl.x) / maxDist; 
             spinEffect.y = (spinIndicator.y - spinBallControl.y) / maxDist;
             
             if (!isFinite(spinEffect.x)) spinEffect.x = 0;
             if (!isFinite(spinEffect.y)) spinEffect.y = 0;
             
             drawSpinControl();
        }


        // --- 10. ASIGNACIÓN DE EVENTOS ---
        
        canvas.addEventListener('mousedown', handleTableInteractionStart);
        canvas.addEventListener('mousemove', handleTableInteractionMove);
        canvas.addEventListener('touchstart', handleTableInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleTableInteractionMove, { passive: false });
        
        window.addEventListener('mouseup', handleGlobalInteractionEnd);
        window.addEventListener('touchend', handleGlobalInteractionEnd);
        
        function handleSpinInteractionStart(event) { 
            startAudioContext(); 
            if (event.cancelable) event.preventDefault(); 
            isSettingSpin = true; 
            updateSpin(getPosInCanvas(event, canvasSpin)); 
        }
        function handleSpinInteractionEnd() { 
            isSettingSpin = false; 
        }
        function handleSpinInteractionMove(event) { 
            if (!isSettingSpin) return; 
            if (event.cancelable) event.preventDefault(); 
            updateSpin(getPosInCanvas(event, canvasSpin)); 
        }
        canvasSpin.addEventListener('mousedown', handleSpinInteractionStart);
        canvasSpin.addEventListener('mousemove', handleSpinInteractionMove);
        canvasSpin.addEventListener('mouseup', handleSpinInteractionEnd);
        canvasSpin.addEventListener('mouseleave', handleSpinInteractionEnd);
        canvasSpin.addEventListener('touchstart', handleSpinInteractionStart, { passive: false });
        canvasSpin.addEventListener('touchmove', handleSpinInteractionMove, { passive: false });
        canvasSpin.addEventListener('touchend', handleSpinInteractionEnd);
        canvasSpin.addEventListener('touchcancel', handleSpinInteractionEnd);
        
        if(resetButton) {
             resetButton.addEventListener('click', () => {
                 startAudioContext();
                 if (lastCueBallPos && lastBlackBallPos) { 
                     restoreLastPositions(); 
                 }
                 else { 
                     resetToStartPositions(); 
                 }
             });
        }
        
        // Observador de Redimensionamiento
        let resizeObserver;
        if (typeof ResizeObserver !== 'undefined') {
             resizeObserver = new ResizeObserver(entries => {
                 window.requestAnimationFrame(() => { 
                     if (!Array.isArray(entries) || !entries.length) { return; }
                     setupCanvas();
                 });
             });
             
            if (canvas.parentElement) { 
                resizeObserver.observe(canvas.parentElement); 
            }
            else { 
                window.addEventListener('resize', setupCanvas); 
            }
        } else { 
            window.addEventListener('resize', setupCanvas); 
        }

        
        function shootBall(powerPercent) {
            // --- INICIO CAMBIO: Permitir tiro desde 'aimLocked' ---
            if ((gameState !== 'aiming' && gameState !== 'aimLocked') || !cueBall.active) return;
            // --- FIN CAMBIO ---
            
            lastCueBallPos = { x: cueBall.x, y: cueBall.y };
            lastBlackBallPos = { x: blackBall.x, y: blackBall.y };
            wasLastBlackBallActive = blackBall.active;

            gameState = 'simulating';
            document.body.classList.remove('aim-locked'); // Quitar clase CSS al disparar
            
            const maxPull = (TABLE_WIDTH || 500) * 0.20;
            let power = maxPull * (powerPercent / 100);

            if (!isFinite(power)) power = 0;

            if (soundsReady) { 
                try {
                    const pNorm = powerPercent / 100;
                    cueHitSound.triggerAttackRelease("C3", "8n", Tone.now(), pNorm * 0.8 + 0.2); 
                } catch (e) {}
            }
            
            if (isFinite(aimDir.x) && isFinite(aimDir.y) && isFinite(power)) {
                 cueBall.vx = aimDir.x * power * POWER_MULTIPLIER; 
                 cueBall.vy = aimDir.y * power * POWER_MULTIPLIER;
            } else {
                 cueBall.vx = 0; cueBall.vy = 0;
            }
        }

        function handleShoot() {
            // --- INICIO CAMBIO: Permitir tiro desde 'aimLocked' ---
            if (gameState !== 'aiming' && gameState !== 'aimLocked') {
            // --- FIN CAMBIO ---
                powerBar.value = 0; 
                return;
            }
            const powerValue = parseInt(powerBar.value);
            if (powerValue > 5) { 
                shootBall(powerValue);
            }
            setTimeout(() => {
                powerBar.value = 0;
            }, 100); 
        }

        powerBar.addEventListener('mouseup', handleShoot);
        powerBar.addEventListener('touchend', handleShoot);


        // --- 11. MANEJO DE PANTALLA COMPLETA ---
        const fullscreenButton = document.getElementById('fullscreenButton');
        const appContainer = document.documentElement; 
        async function toggleFullScreen() {
            try {
                if (!document.fullscreenElement &&    
                    !document.mozFullScreenElement && 
                    !document.webkitFullscreenElement && 
                    !document.msFullscreenElement) {  
                    
                    if (appContainer.requestFullscreen) {
                        await appContainer.requestFullscreen();
                    } else if (appContainer.mozRequestFullScreen) { 
                        await appContainer.mozRequestFullScreen();
                    } else if (appContainer.webkitRequestFullscreen) { 
                        await appContainer.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                    } else if (appContainer.msRequestFullscreen) { 
                        await appContainer.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        await document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { 
                        await document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { 
                        await document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { 
                        await document.msExitFullscreen();
                    }
                }
            } catch (err) {
                console.warn("No se pudo activar/desactivar la pantalla completa.", err);
            }
        }

        function handleFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            document.body.classList.toggle('in-fullscreen', isFullscreen);
            
            setTimeout(() => {
                setupCanvas();
                drawSpinControl(); 
            }, 300); 
        }

        if (fullscreenButton) {
            fullscreenButton.addEventListener('click', async () => {
                await startAudioContext(); 
                await toggleFullScreen();
            });
        }

        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);


        // --- 12. INICIO DE LA APLICACIÓN ---
        function setupSpinControl() {
             const spinSize = 100; 
             canvasSpin.width = spinSize; canvasSpin.height = spinSize; 
             spinBallControl.radius = canvasSpin.width * 0.4; 
             spinBallControl.x = canvasSpin.width / 2; spinBallControl.y = canvasSpin.height / 2; 
             spinIndicator.x = spinBallControl.x; spinIndicator.y = spinBallControl.y;
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupSpinControl();
            // setupCanvas(); // <-- CORRECCIÓN: No llamar aquí. Causa race condition.
            gameLoop(); 
            drawSpinControl(); 
        });
    </script>
</body>
</html>

