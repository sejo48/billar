<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Prevenir zoom y asegurar escala correcta en móviles -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Simulador de Trayectoria de Billar</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Librería de Sonido (Tone.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%; 
            height: 100dvh; 
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
            background-color: #111827; 
        }
        
        canvas {
            background-color: #059669; 
            display: block; 
            touch-action: none; 
        }

        #poolTable { cursor: crosshair; }
        body.aim-locked #poolTable { cursor: default; }
        #spinControlCanvas { cursor: pointer; }
        .elegant-script { font-family: 'Dancing Script', cursive; }

        /* Mantiene la proporción 2:1 estricta */
        .table-container-fixed {
            aspect-ratio: 2 / 1;
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            @supports not (aspect-ratio: 2 / 1) {
                height: 0;
                padding-bottom: 50%; 
            }
        }

        /* Barra de Fuerza Compacta */
        #powerBar {
            -webkit-appearance: slider-vertical; 
            writing-mode: bt-lr; 
            width: 16px; /* Reducido de 24px */
            height: 100px; /* Reducido de 140px */
            padding: 0;
            transform: rotate(180deg); 
            touch-action: none; 
            margin: 5px 0;
        }
        #powerBar::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 24px; height: 24px; /* Reducido de 32px */
            background: #2563eb; cursor: pointer;
            border-radius: 50%; border: 2px solid #f0f0f0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #powerBar::-moz-range-thumb {
            width: 24px; height: 24px; /* Reducido de 32px */
            background: #2563eb; cursor: pointer;
            border-radius: 50%; border: 2px solid #f0f0f0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* MODO PAISAJE MÓVIL */
        @media (max-height: 600px) and (orientation: landscape) {
            #header-block, #footer-credits { display: none !important; }
            #main-container { flex-direction: row !important; align-items: center; }
            #controls-wrapper {
                width: auto !important; flex-direction: column !important;
                padding: 0.25rem !important; gap: 0.25rem !important;
                height: 100%; justify-content: center;
            }
            #powerBar { height: 80px; }
            button { padding: 0.2rem 0.5rem !important; font-size: 0.75rem !important; }
        }

        /* PANTALLA COMPLETA */
        body.maximize-area {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999;
            width: 100vw; height: 100dvh; background-color: #111827;
        }
        body.maximize-area #header-block, body.maximize-area #footer-credits { display: none !important; }
        body.maximize-area #table-wrapper { height: 100%; max-height: 100%; padding: 0; }
        body.maximize-area #main-container { height: 100%; width: 100%; padding: 0; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center p-2 h-full">

    <div id="main-container" class="w-full max-w-7xl flex flex-col md:flex-row items-center flex-grow min-h-0 gap-2 md:gap-3">

        <div id="main-content-wrapper" class="flex-1 flex flex-col items-center w-full min-h-0 h-full justify-center">
            <div id="header-block" class="flex flex-col items-center w-full px-2 py-1 gap-1 flex-shrink-0 text-center transition-all">
                <h1 class="text-xl md:text-3xl font-bold text-white leading-tight">Simulador de Billar</h1>
                <p class="text-xs md:text-sm text-gray-400">
                    <span class="hidden md:inline">Apunta con el ratón.</span>
                    <span class="md:hidden">Arrastra para apuntar.</span>
                    <b><span class="hidden md:inline">Clic</span><span class="md:hidden">Levanta</span> para bloquear.</b>
                </p>
            </div>

            <div id="table-wrapper" class="flex-1 w-full flex items-center justify-center min-h-0 py-1">
                <div class="table-container-fixed bg-yellow-900 border-4 md:border-8 border-yellow-800 rounded-lg shadow-2xl overflow-hidden relative">
                    <canvas id="poolTable" class="w-full h-full touch-none"></canvas>
                </div>
            </div>

            <div id="footer-credits" class="py-1 flex-shrink-0">
                <p class="elegant-script text-base md:text-xl text-gray-500">
                    Por Jorge Hernández
                </p>
            </div>
        </div>

        <!-- Panel de Controles Compacto -->
        <div id="controls-wrapper" class="w-full md:w-24 lg:w-32 flex flex-row md:flex-col items-center justify-around md:justify-center bg-gray-800 rounded-lg p-2 md:p-3 gap-3 md:gap-4 flex-shrink-0 shadow-lg border border-gray-700">
            
            <div class="flex flex-col items-center justify-center">
                <div class="p-1 rounded-full bg-gray-700 shadow-inner border border-gray-600">
                    <canvas id="spinControlCanvas"></canvas>
                </div>
                <span class="text-[9px] md:text-[10px] text-gray-400 mt-1 uppercase tracking-wider">Efecto</span>
            </div>

            <div class="flex flex-col items-center gap-0">
                <input type="range" id="powerBar" min="0" max="100" value="0" step="1" orient="vertical">
                <label for="powerBar" class="text-[9px] md:text-[10px] text-gray-400 uppercase tracking-wider">Fuerza</label>
            </div>

            <div class="flex flex-col gap-2 w-24 md:w-full">
                <button id="resetButton" class="w-full bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-1 px-2 rounded text-[10px] md:text-xs transition-colors shadow">
                    Reiniciar
                </button>
                <button id="fullscreenButton" class="w-full bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white font-bold py-1 px-2 rounded text-[10px] md:text-xs transition-colors shadow">
                    Pantalla
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN & CONSTANTES FÍSICAS CALIBRADAS ---
        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const canvasSpin = document.getElementById('spinControlCanvas');
        const ctxSpin = canvasSpin.getContext('2d');
        const powerBar = document.getElementById('powerBar');
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Calibración
        const FRICTION = 0.988;           // Fricción
        const MIN_SPEED = 0.04;           // Umbral stop
        const RAIL_RESTITUTION = 0.80;    // Rebote banda
        const BALL_RESTITUTION = 0.92;    // Rebote bola
        const SPIN_FACTOR_CUSHION = 0.45; // Efecto banda
        const POWER_MULTIPLIER = 0.15;    // Potencia REDUCIDA

        // --- ESTADO ---
        let cueBall = { x: 0, y: 0, vx: 0, vy: 0, active: true };
        let blackBall = { x: 0, y: 0, vx: 0, vy: 0, active: true };
        let balls = [cueBall, blackBall];
        let lastCueBallPos = null, lastBlackBallPos = null, wasLastBlackBallActive = true; 
        let mousePos = { x: 0, y: 0 };
        let draggingBall = null;
        let isSettingSpin = false;
        let gameState = 'aiming'; 
        let aimDir = { x: 1, y: 0 };
        let spinEffect = { x: 0, y: 0 };
        let spinBallControl = { x: 0, y: 0, radius: 0 };
        let spinIndicator = { x: 0, y: 0 };

        let TABLE_WIDTH = 0, TABLE_HEIGHT = 0;
        let CUSHION_SIZE, BALL_RADIUS, POCKET_RADIUS;
        let POCKETS = [], PLAYABLE_RECT = {};

        // --- UTILIDADES ---
        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        // --- SONIDOS ---
        let soundsReady = false;
        let cueHitSound, ballCollisionSound, cushionHitSound, pocketSound;

        function initSounds() {
             if (soundsReady) return;
             try {
                 cueHitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                 ballCollisionSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 5, envelope: { attack: 0.001, decay: 0.15, sustain: 0.01, release: 0.1 } }).toDestination();
                 ballCollisionSound.volume.value = -6;
                 cushionHitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 1, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
                 cushionHitSound.volume.value = -12;
                 pocketSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                 pocketSound.volume.value = -6;
                 soundsReady = true;
             } catch (e) { console.error(e); soundsReady = false; }
        }
        async function startAudioContext() {
             if (Tone.context.state !== 'running') { try { await Tone.start(); } catch (e) {} }
             if (!soundsReady) { initSounds(); }
        }

        function setupCanvas() {
             const container = canvas.parentElement;
             if (!container || container.clientWidth === 0) { requestAnimationFrame(setupCanvas); return; }
             canvas.width = container.clientWidth;
             canvas.height = container.clientHeight;
             if (canvas.width <= 0) { requestAnimationFrame(setupCanvas); return; }
             
             TABLE_WIDTH = canvas.width; TABLE_HEIGHT = canvas.height;
             CUSHION_SIZE = TABLE_WIDTH * 0.045; 
             BALL_RADIUS = Math.max(TABLE_WIDTH * 0.015, 5); 
             POCKET_RADIUS = BALL_RADIUS * 1.8;
             PLAYABLE_RECT = {
                 left: CUSHION_SIZE, top: CUSHION_SIZE,
                 width: TABLE_WIDTH - 2 * CUSHION_SIZE, height: TABLE_HEIGHT - 2 * CUSHION_SIZE,
                 right: TABLE_WIDTH - CUSHION_SIZE, bottom: TABLE_HEIGHT - CUSHION_SIZE
             };
             POCKETS = [
                 { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.top }, { x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.top }, { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.top },
                 { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.bottom },{ x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.bottom }, { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.bottom }
             ];
             if ((gameState === 'aiming' || gameState === 'aimLocked') && !draggingBall) {
                 if (lastCueBallPos === null) resetToStartPositions(); 
                 else { balls.forEach(b => { if (b.active) { b.x = clamp(b.x, PLAYABLE_RECT.left+BALL_RADIUS, PLAYABLE_RECT.right-BALL_RADIUS); b.y = clamp(b.y, PLAYABLE_RECT.top+BALL_RADIUS, PLAYABLE_RECT.bottom-BALL_RADIUS); }}); }
             }
        }

        function resetToStartPositions() {
            gameState = 'aiming'; document.body.classList.remove('aim-locked'); 
            if (!PLAYABLE_RECT.width) return;
            cueBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.25; cueBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
            blackBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.7; blackBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            blackBall.vx = 0; blackBall.vy = 0; blackBall.active = true;
            balls = [cueBall, blackBall]; lastCueBallPos = null; spinEffect = {x:0, y:0};
            if (spinBallControl.x) { spinIndicator = {...spinBallControl}; drawSpinControl(); }
        }
        function restoreLastPositions() {
             if (!lastCueBallPos) { resetToStartPositions(); return; }
             gameState = 'aiming'; document.body.classList.remove('aim-locked'); 
             cueBall.x = lastCueBallPos.x; cueBall.y = lastCueBallPos.y; cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
             blackBall.x = lastBlackBallPos.x; blackBall.y = lastBlackBallPos.y; blackBall.vx = 0; blackBall.vy = 0; blackBall.active = wasLastBlackBallActive;
             balls = [cueBall, blackBall]; spinEffect = {x:0, y:0};
             if (spinBallControl.x) { spinIndicator = {...spinBallControl}; drawSpinControl(); }
        }

        // --- DIBUJO ---
        function drawTable() {
             if (!TABLE_WIDTH) return;
             ctx.clearRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
             const woodGradient = ctx.createLinearGradient(0, 0, 0, TABLE_HEIGHT);
             woodGradient.addColorStop(0, '#6b2112'); woodGradient.addColorStop(1, '#4a170c');
             ctx.fillStyle = woodGradient; ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
             
             const diamondR = CUSHION_SIZE * 0.18; 
             const segX = PLAYABLE_RECT.width / 8, segY = PLAYABLE_RECT.height / 4;
             const drawD = (x,y) => {
                if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowBlur = 2; ctx.shadowOffsetY = 1;
                const g = ctx.createRadialGradient(x, y-1, 0, x, y, diamondR); g.addColorStop(0, '#FFF'); g.addColorStop(1, '#e0e0e0');
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, diamondR, 0, Math.PI*2); ctx.fill(); ctx.restore();
             };
             // Rieles
             for(let i=1; i<=7; i++) { drawD(PLAYABLE_RECT.left + segX*i, PLAYABLE_RECT.top/2); drawD(PLAYABLE_RECT.left + segX*i, PLAYABLE_RECT.bottom + CUSHION_SIZE/2); }
             for(let i=1; i<=3; i++) { drawD(PLAYABLE_RECT.left/2, PLAYABLE_RECT.top + segY*i); drawD(PLAYABLE_RECT.right + CUSHION_SIZE/2, PLAYABLE_RECT.top + segY*i); }
             
             // Fieltro
             ctx.fillStyle = '#059669'; ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
             
             const baulkX = PLAYABLE_RECT.left + segX*2;
             ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1;
             ctx.beginPath(); ctx.moveTo(baulkX, PLAYABLE_RECT.top); ctx.lineTo(baulkX, PLAYABLE_RECT.bottom); ctx.stroke();
             
             // Sombras internas
             ctx.fillStyle = 'rgba(0,0,0,0.3)';
             ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, 4); 
             ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.bottom-4, PLAYABLE_RECT.width, 4); 
             ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, 4, PLAYABLE_RECT.height); 
             ctx.fillRect(PLAYABLE_RECT.right-4, PLAYABLE_RECT.top, 4, PLAYABLE_RECT.height); 

             // Buchacas
             POCKETS.forEach(p => {
                const g = ctx.createRadialGradient(p.x, p.y, POCKET_RADIUS*0.5, p.x, p.y, POCKET_RADIUS);
                g.addColorStop(0, '#111'); g.addColorStop(1, '#000');
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI*2); ctx.fill();
             });
        }

        function drawBall(ball, color) {
            if (!Number.isFinite(ball.x) || !Number.isFinite(ball.y) || !Number.isFinite(BALL_RADIUS)) return;
            ctx.save(); ctx.beginPath(); ctx.arc(ball.x + BALL_RADIUS*0.1, ball.y + BALL_RADIUS*0.15, BALL_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = BALL_RADIUS*0.3; ctx.fill(); ctx.restore();
            ctx.beginPath(); 
            const g = ctx.createRadialGradient(ball.x - BALL_RADIUS*0.3, ball.y - BALL_RADIUS*0.4, BALL_RADIUS*0.05, ball.x, ball.y, BALL_RADIUS);
            if(color==='#FFFFFF'){ g.addColorStop(0,'#FFF'); g.addColorStop(1,'#ccc'); } else { g.addColorStop(0,'#666'); g.addColorStop(1,'#000'); }
            ctx.fillStyle = g; ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2); ctx.fill();
        }
        function drawBlackBall() {
            if (!Number.isFinite(blackBall.x) || !Number.isFinite(blackBall.y)) return;
            drawBall(blackBall, '#000');
            ctx.beginPath(); ctx.arc(blackBall.x, blackBall.y, BALL_RADIUS*0.5, 0, Math.PI*2); ctx.fillStyle='#FFF'; ctx.fill();
            ctx.fillStyle='#000'; ctx.font=`bold ${BALL_RADIUS*0.75}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('8', blackBall.x, blackBall.y + BALL_RADIUS*0.05);
        }
        function drawSpinControl() {
            if(!canvasSpin.width || !Number.isFinite(spinBallControl.radius)) return;
            ctxSpin.clearRect(0,0,100,100);
            ctxSpin.save(); ctxSpin.beginPath(); ctxSpin.arc(spinBallControl.x+1, spinBallControl.y+2, spinBallControl.radius, 0, Math.PI*2);
            ctxSpin.fillStyle='rgba(0,0,0,0.2)'; ctxSpin.fill(); ctxSpin.restore();
            const g = ctxSpin.createRadialGradient(spinBallControl.x-12, spinBallControl.y-16, 2, spinBallControl.x, spinBallControl.y, 40);
            g.addColorStop(0,'#FFF'); g.addColorStop(1,'#ccc'); ctxSpin.fillStyle=g;
            ctxSpin.beginPath(); ctxSpin.arc(spinBallControl.x, spinBallControl.y, spinBallControl.radius, 0, Math.PI*2); ctxSpin.fill();
            ctxSpin.beginPath(); ctxSpin.arc(spinIndicator.x, spinIndicator.y, 5, 0, Math.PI*2);
            ctxSpin.fillStyle='rgba(220,38,38,0.9)'; ctxSpin.fill();
        }

        // --- LÓGICA FÍSICA COMPARTIDA ---
        function getWallCollision(pos, dir) {
            let tMin = Infinity, type = null;
            if(dir.x > 0.001) { let t = (PLAYABLE_RECT.right - BALL_RADIUS - pos.x)/dir.x; if(t>0 && t<tMin) {tMin=t; type='right';} }
            else if(dir.x < -0.001) { let t = (PLAYABLE_RECT.left + BALL_RADIUS - pos.x)/dir.x; if(t>0 && t<tMin) {tMin=t; type='left';} }
            if(dir.y > 0.001) { let t = (PLAYABLE_RECT.bottom - BALL_RADIUS - pos.y)/dir.y; if(t>0 && t<tMin) {tMin=t; type='bottom';} }
            else if(dir.y < -0.001) { let t = (PLAYABLE_RECT.top + BALL_RADIUS - pos.y)/dir.y; if(t>0 && t<tMin) {tMin=t; type='top';} }
            return {t:tMin, type:type};
        }
        function getBallCollision(pos, dir, target) {
            const v = {x:target.x-pos.x, y:target.y-pos.y};
            const dot = v.x*dir.x + v.y*dir.y; if(dot<=0) return {t:Infinity};
            const distSq = (v.x*v.x + v.y*v.y) - (dot*dot);
            const colRadSq = (BALL_RADIUS*2)**2;
            if(distSq >= colRadSq) return {t:Infinity};
            const t = dot - Math.sqrt(colRadSq - distSq);
            return {t: t>0 ? t : Infinity};
        }

        // --- TRAYECTORIA PREDICTIVA ---
        function drawFullTrajectory() {
            if ((gameState !== 'aiming' && gameState !== 'aimLocked') || !cueBall.active) return;
            
            let pos = {x:cueBall.x, y:cueBall.y};
            let dir = {...aimDir};
            let mag = Math.hypot(dir.x, dir.y);
            if(mag < 0.01) return;
            dir.x /= mag; dir.y /= mag;
            
            let wall = getWallCollision(pos, dir);
            let ball = blackBall.active ? getBallCollision(pos, dir, blackBall) : {t:Infinity};
            let t = Math.min(wall.t, ball.t);
            if(t === Infinity || t > 2000) t = 2000;

            let hit = {x: pos.x + dir.x*t, y: pos.y + dir.y*t};
            
            ctx.beginPath(); ctx.moveTo(pos.x, pos.y); ctx.lineTo(hit.x, hit.y);
            ctx.strokeStyle = gameState==='aimLocked' ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.5)';
            ctx.setLineDash(gameState==='aimLocked' ? [] : [4,4]); ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);

            if(ball.t < wall.t && blackBall.active) {
                let bDir = {x:blackBall.x-hit.x, y:blackBall.y-hit.y};
                let bMag = Math.hypot(bDir.x, bDir.y);
                if(bMag > 0.001) { bDir.x/=bMag; bDir.y/=bMag; drawPath(blackBall, bDir, 'rgba(255,255,0,0.6)'); }
                
                let tang = {x:-bDir.y, y:bDir.x}; 
                if(dir.x*tang.x + dir.y*tang.y < 0) { tang.x*=-1; tang.y*=-1; }
                let follow = spinEffect.y < 0 ? -spinEffect.y : 0;
                let cDir = { x: bDir.x*follow + tang.x, y: bDir.y*follow + tang.y };
                let cMag = Math.hypot(cDir.x, cDir.y);
                if(cMag>0.01) { 
                    cDir.x/=cMag; cDir.y/=cMag; 
                    drawPath({x:hit.x-bDir.x*BALL_RADIUS, y:hit.y-bDir.y*BALL_RADIUS}, cDir, 'rgba(255,165,0,0.6)'); 
                }
            } else if(isFinite(wall.t)) {
                 let nDir = {...dir};
                 if(wall.type.match(/left|right/)) { 
                     nDir.x *= -1; 
                     nDir.y += spinEffect.x * SPIN_FACTOR_CUSHION * (wall.type=='right'?-1:1) * Math.sign(nDir.y||1);
                 } else { 
                     nDir.y *= -1; 
                     nDir.x += spinEffect.x * SPIN_FACTOR_CUSHION * (wall.type=='bottom'?1:-1) * Math.sign(nDir.x||1);
                 }
                 let nMag = Math.hypot(nDir.x, nDir.y); 
                 if(nMag>0.01) { nDir.x/=nMag; nDir.y/=nMag; drawPath(hit, nDir, 'rgba(255,255,255,0.4)'); }
            }
        }
        function drawPath(pos, dir, color) {
            if (!Number.isFinite(pos.x) || !Number.isFinite(pos.y)) return;
            ctx.beginPath(); ctx.moveTo(pos.x, pos.y);
            let p = {...pos}, d = {...dir};
            let w = getWallCollision(p, d); 
            if(isFinite(w.t)) {
                let h = {x:p.x+d.x*w.t, y:p.y+d.y*w.t}; ctx.lineTo(h.x, h.y); 
            } else {
                ctx.lineTo(p.x+d.x*1000, p.y+d.y*1000);
            }
            ctx.strokeStyle=color; ctx.stroke();
        }

        // --- DIBUJAR TACO ---
        function drawPoolCue() {
            if(!cueBall.active || !Number.isFinite(BALL_RADIUS) || BALL_RADIUS <= 0) return;
            
            const ang = Math.atan2(aimDir.y, aimDir.x);
            let pull = powerBar.value * 2;
            
            // Dimensiones proporcionales a la bola
            const tipW = BALL_RADIUS * 0.6;   // Punta más fina
            const buttW = BALL_RADIUS * 1.2;  // Mango más grueso
            const len = TABLE_WIDTH * 0.4;    // Largo relativo a la mesa
            const offset = BALL_RADIUS * 1.5 + pull; // Distancia de la bola

            ctx.save(); 
            ctx.translate(cueBall.x, cueBall.y); 
            ctx.rotate(ang);
            
            // Dibujar el taco con forma cónica (Path)
            ctx.beginPath();
            ctx.moveTo(-offset, -tipW/2);              // Punta arriba
            ctx.lineTo(-offset - len, -buttW/2);       // Mango arriba
            ctx.lineTo(-offset - len, buttW/2);        // Mango abajo
            ctx.lineTo(-offset, tipW/2);               // Punta abajo
            ctx.closePath();

            // Color madera degradado
            const grad = ctx.createLinearGradient(-offset - len, 0, -offset, 0);
            grad.addColorStop(0, '#5c4033'); // Mango oscuro
            grad.addColorStop(1, '#d2b48c'); // Punta clara
            ctx.fillStyle = grad;
            ctx.fill();
            
            // Virola (punta blanca)
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(-offset - (BALL_RADIUS*0.4), -tipW/2, BALL_RADIUS*0.4, tipW);
            
            // Suela (punta azul)
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(-offset, -tipW/2, -BALL_RADIUS*0.15, tipW);

            ctx.restore();
        }

        function drawGhostBall() {
             if(gameState!=='aiming' || draggingBall) return;
             ctx.save(); ctx.globalAlpha=0.3; ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, BALL_RADIUS, 0, Math.PI*2);
             ctx.fillStyle='#fff'; ctx.fill(); ctx.restore();
        }

        // --- FÍSICA REAL (CALIBRADA) ---
        function updatePhysics() {
            let moving = false;
            
            balls.forEach(b => { 
                if(b.active) { 
                    b.vx *= FRICTION; 
                    b.vy *= FRICTION; 
                    if(Math.hypot(b.vx, b.vy) < MIN_SPEED) { b.vx=0; b.vy=0; } 
                    else { b.x += b.vx; b.y += b.vy; moving=true; }
                } 
            });
            
            balls.forEach(b => {
                if(!b.active || (b.vx==0 && b.vy==0)) return;
                
                POCKETS.forEach(p => { 
                    if(Math.hypot(b.x-p.x, b.y-p.y) < POCKET_RADIUS) { 
                        b.active=false; b.vx=0; b.vy=0; 
                        try{pocketSound.triggerAttackRelease("16n");}catch(e){} 
                        setTimeout(()=>{ if(b==cueBall) resetToStartPositions(); else b.active=true; }, 500); 
                    } 
                });
                
                let hit = false;
                let spinX = (b === cueBall) ? spinEffect.x : 0;

                if(b.x + BALL_RADIUS > PLAYABLE_RECT.right) { 
                    b.x = PLAYABLE_RECT.right - BALL_RADIUS; 
                    b.vx *= -RAIL_RESTITUTION;
                    if(b === cueBall) b.vy += spinX * SPIN_FACTOR_CUSHION * -1 * Math.sign(b.vy||1);
                    hit = true;
                } else if(b.x - BALL_RADIUS < PLAYABLE_RECT.left) { 
                    b.x = PLAYABLE_RECT.left + BALL_RADIUS; 
                    b.vx *= -RAIL_RESTITUTION;
                    if(b === cueBall) b.vy += spinX * SPIN_FACTOR_CUSHION * 1 * Math.sign(b.vy||1);
                    hit = true;
                }
                if(b.y + BALL_RADIUS > PLAYABLE_RECT.bottom) { 
                    b.y = PLAYABLE_RECT.bottom - BALL_RADIUS; 
                    b.vy *= -RAIL_RESTITUTION;
                    if(b === cueBall) b.vx += spinX * SPIN_FACTOR_CUSHION * 1 * Math.sign(b.vx||1);
                    hit = true;
                } else if(b.y - BALL_RADIUS < PLAYABLE_RECT.top) { 
                    b.y = PLAYABLE_RECT.top + BALL_RADIUS; 
                    b.vy *= -RAIL_RESTITUTION;
                    if(b === cueBall) b.vx += spinX * SPIN_FACTOR_CUSHION * -1 * Math.sign(b.vx||1);
                    hit = true;
                }

                if(hit && soundsReady) {
                    try { 
                        let v = Math.min(Math.hypot(b.vx, b.vy)/8, 1);
                        cushionHitSound.triggerAttackRelease("C2", "16n", Tone.now(), v*0.7);
                    } catch(e){}
                    if(b === cueBall) spinEffect.x *= 0.8; 
                }
            });

            if(cueBall.active && blackBall.active) {
                 let dx = blackBall.x - cueBall.x;
                 let dy = blackBall.y - cueBall.y;
                 let dist = Math.hypot(dx, dy);
                 
                 if(dist < BALL_RADIUS*2 && dist > 0.0001) {
                     try{ballCollisionSound.triggerAttackRelease("G4","16n");}catch(e){}
                     
                     let nx = dx/dist, ny = dy/dist;
                     let v1n = cueBall.vx * nx + cueBall.vy * ny;
                     let v2n = blackBall.vx * nx + blackBall.vy * ny;
                     let dv = v1n - v2n;
                     let impulse = (-(1 + BALL_RESTITUTION) * dv) / 2; 
                     
                     cueBall.vx += impulse * nx; 
                     cueBall.vy += impulse * ny; 
                     blackBall.vx -= impulse * nx; 
                     blackBall.vy -= impulse * ny;
                     
                     let overlap = (BALL_RADIUS*2 - dist) / 2;
                     cueBall.x -= overlap * nx; cueBall.y -= overlap * ny;
                     blackBall.x += overlap * nx; blackBall.y += overlap * ny;
                     
                     spinEffect.y = 0; 
                 }
            }
            
            if(!moving) {
                setTimeout(()=> { 
                    if(balls.every(b=>!b.active || (Math.abs(b.vx)<0.001 && Math.abs(b.vy)<0.001)) && gameState==='simulating') { 
                        gameState='aiming'; 
                        document.body.classList.remove('aim-locked'); 
                    } 
                }, 100);
            }
        }

        function gameLoop() {
            if(gameState==='simulating') updatePhysics();
            drawTable();
            if(gameState!=='simulating') { drawFullTrajectory(); drawPoolCue(); drawGhostBall(); }
            balls.forEach(b => { if(b.active) drawBall(b, b==cueBall?'#FFFFFF':'#000'); });
            if(blackBall.active) drawBlackBall();
            requestAnimationFrame(gameLoop);
        }

        // --- EVENTOS ---
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            let cx = e.touches?e.touches[0].clientX:e.clientX, cy = e.touches?e.touches[0].clientY:e.clientY;
            return { x: (cx-r.left)*(canvas.width/r.width), y: (cy-r.top)*(canvas.height/r.height) };
        }
        canvas.addEventListener('mousedown', e => handleStart(e));
        canvas.addEventListener('touchstart', e => { handleStart(e); }, {passive:false});
        canvas.addEventListener('mousemove', e => handleMove(e));
        canvas.addEventListener('touchmove', e => { handleMove(e); }, {passive:false});
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        function handleStart(e) {
            startAudioContext();
            if(gameState==='simulating') return;
            let p = getPos(e); if(!p) return; mousePos = p;
            
            // Distancias
            let dC = Math.hypot(p.x-cueBall.x, p.y-cueBall.y);
            let dB = Math.hypot(p.x-blackBall.x, p.y-blackBall.y);
            
            // Radio de agarre más generoso
            const grabDist = BALL_RADIUS * 2.5;

            if(dC < grabDist && cueBall.active) {
                draggingBall = cueBall; 
            } else if(dB < grabDist && blackBall.active) {
                draggingBall = blackBall; // Ahora puedes mover la negra
            }
            else if(isTouchDevice && gameState==='aiming') { /* solo mover */ } 
            else if(!isTouchDevice && gameState==='aiming') { gameState='aimLocked'; document.body.classList.add('aim-locked'); updateAim(p); }
            else if(gameState==='aimLocked') { gameState='aiming'; document.body.classList.remove('aim-locked'); }
        }

        function handleMove(e) {
            let p = getPos(e); if(!p) return; mousePos = p;
            if(draggingBall) { 
                // Mover con límites de mesa
                draggingBall.x = clamp(p.x, PLAYABLE_RECT.left + BALL_RADIUS, PLAYABLE_RECT.right - BALL_RADIUS);
                draggingBall.y = clamp(p.y, PLAYABLE_RECT.top + BALL_RADIUS, PLAYABLE_RECT.bottom - BALL_RADIUS);
                e.preventDefault(); 
            }
            else if(cueBall.active && (isTouchDevice || gameState==='aiming')) { updateAim(p); if(e.type=='touchmove') e.preventDefault(); }
        }

        function handleEnd() {
            if(isTouchDevice && !draggingBall && gameState==='aiming') { gameState='aimLocked'; document.body.classList.add('aim-locked'); }
            draggingBall = null; isSettingSpin=false;
        }
        function updateAim(p) {
            let dx=p.x-cueBall.x, dy=p.y-cueBall.y, m=Math.hypot(dx,dy);
            if(m>0.1) { aimDir.x=dx/m; aimDir.y=dy/m; }
        }

        // Spin
        function setupSpinControl() {
             const spinSize = 70; // Reducido de 100 a 70
             canvasSpin.width = spinSize; canvasSpin.height = spinSize; 
             spinBallControl.radius = canvasSpin.width * 0.4; 
             spinBallControl.x = canvasSpin.width / 2; spinBallControl.y = canvasSpin.height / 2; 
             spinIndicator = {x: spinBallControl.x, y: spinBallControl.y};
        }
        function setSpin(e) {
            const r = canvasSpin.getBoundingClientRect();
            let cx = e.touches?e.touches[0].clientX:e.clientX, cy = e.touches?e.touches[0].clientY:e.clientY;
            
            const centerX = canvasSpin.width / 2;
            const centerY = canvasSpin.height / 2;
            const maxDist = canvasSpin.width * 0.4;
            
            // Corregir cálculo relativo al nuevo tamaño dinámico
            let dx = cx - r.left - centerX;
            let dy = cy - r.top - centerY;
            
            let d = Math.hypot(dx, dy);
            if(d > maxDist) { 
                let a = Math.atan2(dy, dx); 
                dx = Math.cos(a) * maxDist; 
                dy = Math.sin(a) * maxDist; 
            }
            
            spinIndicator = {x: centerX + dx, y: centerY + dy}; 
            spinEffect = {x: dx/maxDist, y: dy/maxDist}; 
            drawSpinControl();
        }
        ['mousedown','mousemove','touchstart','touchmove'].forEach(ev => canvasSpin.addEventListener(ev, e => { if(ev.match(/start|down/)) isSettingSpin=true; if(isSettingSpin) { e.preventDefault(); setSpin(e); } }, {passive:false}));
        ['mouseup','touchend'].forEach(ev => window.addEventListener(ev, () => isSettingSpin=false));

        // Disparo
        powerBar.addEventListener('input', () => { if(gameState==='aiming'||gameState==='aimLocked') drawPoolCue(); });
        ['mouseup','touchend'].forEach(ev => powerBar.addEventListener(ev, () => {
            let v = parseInt(powerBar.value); powerBar.value=0;
            if(v>5 && cueBall.active && (gameState==='aiming'||gameState==='aimLocked')) {
                gameState='simulating'; document.body.classList.remove('aim-locked');
                cueBall.vx = aimDir.x * v * POWER_MULTIPLIER; cueBall.vy = aimDir.y * v * POWER_MULTIPLIER;
                try{ cueHitSound.triggerAttackRelease("C3","8n"); }catch(e){}
            }
        }));
        resetButton.addEventListener('click', () => { startAudioContext(); restoreLastPositions(); });

        // Fullscreen
        const appEl = document.documentElement;
        const fullBtn = document.getElementById('fullscreenButton');
        async function toggleFullScreen() {
            try {
                const isNativeFull = document.fullscreenElement || document.webkitFullscreenElement;
                const isFakeFull = document.body.classList.contains('maximize-area');
                if (isNativeFull) {
                    if (document.exitFullscreen) await document.exitFullscreen();
                    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
                } else if (isFakeFull) {
                    document.body.classList.remove('maximize-area'); setTimeout(setupCanvas, 100);
                } else {
                    if (appEl.requestFullscreen) await appEl.requestFullscreen();
                    else if (appEl.webkitRequestFullscreen) await appEl.webkitRequestFullscreen();
                    else throw new Error("API no soportada");
                }
            } catch (err) {
                document.body.classList.toggle('maximize-area'); setTimeout(setupCanvas, 100);
            }
        }
        function onFullChange() {
            const isFull = !!(document.fullscreenElement || document.webkitFullscreenElement);
            if (isFull) document.body.classList.add('maximize-area');
            else if (!document.body.style.position) document.body.classList.remove('maximize-area');
            setTimeout(setupCanvas, 200);
        }
        document.addEventListener('fullscreenchange', onFullChange);
        document.addEventListener('webkitfullscreenchange', onFullChange);
        fullBtn.addEventListener('click', () => { startAudioContext(); toggleFullScreen(); });

        setupSpinControl();
        gameLoop();
        setupCanvas();
    </script>
</body>
</html>
