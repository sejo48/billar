<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Prevent zooming and ensure proper scaling on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Simulador de Trayectoria de Billar</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Librería de Sonido (Tone.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo para la fuente Inter */
        html, body {
            height: 100%; 
            /* Usar dvh para móviles modernos */
            height: 100dvh;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
            background-color: #111827; 
        }
        
        canvas {
            background-color: #059669; 
            display: block; 
            touch-action: none; 
        }

        #poolTable { cursor: crosshair; }
        body.aim-locked #poolTable { cursor: default; }
        #spinControlCanvas { cursor: pointer; }
        .elegant-script { font-family: 'Dancing Script', cursive; }

        /* Barra de Fuerza */
        #powerBar {
            -webkit-appearance: slider-vertical; 
            writing-mode: bt-lr; 
            width: 24px; 
            height: 140px;
            padding: 0 5px;
            transform: rotate(180deg); 
            touch-action: none; 
        }
        #powerBar::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 32px; height: 32px;
            background: #2563eb; cursor: pointer;
            border-radius: 50%; border: 3px solid #f0f0f0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #powerBar::-moz-range-thumb {
            width: 32px; height: 32px;
            background: #2563eb; cursor: pointer;
            border-radius: 50%; border: 3px solid #f0f0f0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* --- MODO PAISAJE MÓVIL --- */
        @media (max-height: 600px) and (orientation: landscape) {
            #header-block, #footer-credits { display: none !important; }
            #main-container {
                flex-direction: row !important; align-items: center;
            }
            #controls-wrapper {
                width: auto !important; flex-direction: column !important;
                padding: 0.5rem !important; gap: 0.5rem !important;
                height: 100%; justify-content: center;
            }
            #powerBar { height: 100px; }
            button { padding: 0.25rem 0.75rem !important; font-size: 0.875rem !important; }
        }

        /* --- PANTALLA COMPLETA (Real y Simulada) --- */
        /* Esta clase se aplica tanto con la API nativa como con el fallback */
        body.maximize-area {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 9999;
            width: 100vw;
            height: 100dvh;
            background-color: #111827;
        }
        body.maximize-area #header-block,
        body.maximize-area #footer-credits { 
            display: none !important;
        }
        body.maximize-area #table-wrapper {
            height: 100%; 
            max-height: 100%;
            padding: 0;
        }
        body.maximize-area #main-container {
            height: 100%;
            width: 100%;
            padding: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center p-2 h-full">

    <div id="main-container" class="w-full max-w-7xl flex flex-col md:flex-row items-center flex-grow min-h-0 gap-2 md:gap-4">

        <div id="main-content-wrapper" class="flex-1 flex flex-col items-center w-full min-h-0 h-full justify-center">
            <div id="header-block" class="flex flex-col items-center w-full px-2 py-1 gap-1 flex-shrink-0 text-center transition-all">
                <h1 class="text-xl md:text-3xl font-bold text-white leading-tight">Simulador de Billar</h1>
                <p class="text-xs md:text-base text-gray-400">
                    <span class="hidden md:inline">Apunta con el ratón.</span>
                    <span class="md:hidden">Arrastra para apuntar.</span>
                    <b><span class="hidden md:inline">Clic</span><span class="md:hidden">Levanta</span> para bloquear.</b>
                </p>
            </div>

            <div id="table-wrapper" class="flex-1 w-full flex items-center justify-center min-h-0 py-1">
                <div class="aspect-[2/1] w-full max-w-full max-h-full bg-yellow-900 border-4 md:border-8 border-yellow-800 rounded-lg shadow-2xl overflow-hidden relative">
                    <canvas id="poolTable" class="w-full h-full touch-none"></canvas>
                </div>
            </div>

            <div id="footer-credits" class="py-1 flex-shrink-0">
                <p class="elegant-script text-base md:text-xl text-gray-500">
                    Por Jorge Hernández
                </p>
            </div>
        </div>

        <div id="controls-wrapper" class="w-full md:w-32 lg:w-48 flex flex-row md:flex-col items-center justify-around md:justify-center bg-gray-800 rounded-lg p-2 md:p-4 gap-4 md:gap-6 flex-shrink-0 shadow-lg border border-gray-700">
            
            <div class="flex flex-col items-center justify-center">
                <div class="p-1 rounded-full bg-gray-700 shadow-inner border border-gray-600">
                    <canvas id="spinControlCanvas"></canvas>
                </div>
                <span class="text-[10px] md:text-xs text-gray-400 mt-1 uppercase tracking-wider">Efecto</span>
            </div>

            <div class="flex flex-col items-center gap-1">
                <input type="range" id="powerBar" min="0" max="100" value="0" step="1" orient="vertical">
                <label for="powerBar" class="text-[10px] md:text-xs text-gray-400 uppercase tracking-wider">Fuerza</label>
            </div>

            <div class="flex flex-col gap-2 w-24 md:w-full">
                <button id="resetButton" class="w-full bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-2 px-2 rounded text-xs md:text-sm transition-colors shadow" title="Reiniciar">
                    Reiniciar
                </button>
                <button id="fullscreenButton" class="w-full bg-gray-600 hover:bg-gray-700 active:bg-gray-800 text-white font-bold py-2 px-2 rounded text-xs md:text-sm transition-colors shadow" title="Pantalla Completa">
                    Pantalla
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const canvasSpin = document.getElementById('spinControlCanvas');
        const ctxSpin = canvasSpin.getContext('2d');
        const powerBar = document.getElementById('powerBar');
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // --- ESTADO ---
        let cueBall = { x: 0, y: 0, vx: 0, vy: 0, active: true };
        let blackBall = { x: 0, y: 0, vx: 0, vy: 0, active: true };
        let balls = [cueBall, blackBall];
        let lastCueBallPos = null, lastBlackBallPos = null, wasLastBlackBallActive = true; 
        let mousePos = { x: 0, y: 0 };
        let draggingBall = null;
        let isSettingSpin = false;
        let gameState = 'aiming'; 
        let aimDir = { x: 1, y: 0 };
        let spinEffect = { x: 0, y: 0 };
        let spinBallControl = { x: 0, y: 0, radius: 0 };
        let spinIndicator = { x: 0, y: 0 };

        // --- FÍSICA Y MESA ---
        let TABLE_WIDTH = 0, TABLE_HEIGHT = 0;
        let CUSHION_SIZE, BALL_RADIUS, POCKET_RADIUS;
        let POCKETS = [], PLAYABLE_RECT = {};
        const FRICTION = 0.99, MIN_SPEED = 0.05, SPIN_FACTOR_CUSHION = 0.4, POWER_MULTIPLIER = 0.22, RESTITUTION = 0.95; 

        // --- SONIDOS ---
        let soundsReady = false;
        let cueHitSound, ballCollisionSound, cushionHitSound, pocketSound;

        function initSounds() {
             if (soundsReady) return;
             try {
                 cueHitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                 ballCollisionSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 5, envelope: { attack: 0.001, decay: 0.15, sustain: 0.01, release: 0.1 } }).toDestination();
                 ballCollisionSound.volume.value = -6;
                 cushionHitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 1, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
                 cushionHitSound.volume.value = -12;
                 pocketSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                 pocketSound.volume.value = -6;
                 soundsReady = true;
             } catch (e) { console.error(e); soundsReady = false; }
        }
        async function startAudioContext() {
             if (Tone.context.state !== 'running') { try { await Tone.start(); } catch (e) {} }
             if (!soundsReady) { initSounds(); }
        }

        function setupCanvas() {
             const container = canvas.parentElement;
             if (!container || container.clientWidth === 0) { requestAnimationFrame(setupCanvas); return; }
             canvas.width = container.clientWidth;
             canvas.height = container.clientHeight;
             if (canvas.width <= 0) { requestAnimationFrame(setupCanvas); return; }
             
             TABLE_WIDTH = canvas.width; TABLE_HEIGHT = canvas.height;
             CUSHION_SIZE = TABLE_WIDTH * 0.045; BALL_RADIUS = Math.max(TABLE_WIDTH * 0.015, 5); 
             POCKET_RADIUS = BALL_RADIUS * 1.8;
             PLAYABLE_RECT = {
                 left: CUSHION_SIZE, top: CUSHION_SIZE,
                 width: TABLE_WIDTH - 2 * CUSHION_SIZE, height: TABLE_HEIGHT - 2 * CUSHION_SIZE,
                 right: TABLE_WIDTH - CUSHION_SIZE, bottom: TABLE_HEIGHT - CUSHION_SIZE
             };
             POCKETS = [
                 { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.top }, { x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.top }, { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.top },
                 { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.bottom },{ x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.bottom }, { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.bottom }
             ];
             if ((gameState === 'aiming' || gameState === 'aimLocked') && !draggingBall) {
                 if (lastCueBallPos === null) resetToStartPositions(); 
                 else { balls.forEach(b => { if (b.active) { b.x = clamp(b.x, PLAYABLE_RECT.left+BALL_RADIUS, PLAYABLE_RECT.right-BALL_RADIUS); b.y = clamp(b.y, PLAYABLE_RECT.top+BALL_RADIUS, PLAYABLE_RECT.bottom-BALL_RADIUS); }}); }
             }
        }

        function resetToStartPositions() {
            gameState = 'aiming'; document.body.classList.remove('aim-locked'); 
            if (!PLAYABLE_RECT.width) return;
            cueBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.25; cueBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
            blackBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.7; blackBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            blackBall.vx = 0; blackBall.vy = 0; blackBall.active = true;
            balls = [cueBall, blackBall]; lastCueBallPos = null; spinEffect = {x:0, y:0};
            if (spinBallControl.x) { spinIndicator = {...spinBallControl}; drawSpinControl(); }
        }
        function restoreLastPositions() {
             if (!lastCueBallPos) { resetToStartPositions(); return; }
             gameState = 'aiming'; document.body.classList.remove('aim-locked'); 
             cueBall.x = lastCueBallPos.x; cueBall.y = lastCueBallPos.y; cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;
             blackBall.x = lastBlackBallPos.x; blackBall.y = lastBlackBallPos.y; blackBall.vx = 0; blackBall.vy = 0; blackBall.active = wasLastBlackBallActive;
             balls = [cueBall, blackBall]; spinEffect = {x:0, y:0};
             if (spinBallControl.x) { spinIndicator = {...spinBallControl}; drawSpinControl(); }
        }

        // --- DIBUJO SIMPLIFICADO ---
        function drawTable() {
             if (!TABLE_WIDTH) return;
             ctx.clearRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
             const woodGradient = ctx.createLinearGradient(0, 0, 0, TABLE_HEIGHT);
             woodGradient.addColorStop(0, '#6b2112'); woodGradient.addColorStop(0.5, '#a1331d'); woodGradient.addColorStop(1, '#6b2112');
             ctx.fillStyle = woodGradient; ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
             
             const diamondR = CUSHION_SIZE * 0.18; 
             const segX = PLAYABLE_RECT.width / 8, segY = PLAYABLE_RECT.height / 4;
             const drawD = (x,y) => {
                ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.4)'; ctx.shadowBlur = 2; ctx.shadowOffsetY = 1;
                const g = ctx.createRadialGradient(x, y-1, 0, x, y, diamondR); g.addColorStop(0, '#FFF'); g.addColorStop(1, '#e0e0e0');
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, diamondR, 0, Math.PI*2); ctx.fill(); ctx.restore();
             };
             for(let i=1; i<=7; i++) { drawD(PLAYABLE_RECT.left + segX*i, PLAYABLE_RECT.top/2); drawD(PLAYABLE_RECT.left + segX*i, PLAYABLE_RECT.bottom + CUSHION_SIZE/2); }
             for(let i=1; i<=3; i++) { drawD(PLAYABLE_RECT.left/2, PLAYABLE_RECT.top + segY*i); drawD(PLAYABLE_RECT.right + CUSHION_SIZE/2, PLAYABLE_RECT.top + segY*i); }
             
             ctx.fillStyle = '#059669'; ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
             const baulkX = PLAYABLE_RECT.left + segX*2;
             ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1;
             ctx.beginPath(); ctx.moveTo(baulkX, PLAYABLE_RECT.top); ctx.lineTo(baulkX, PLAYABLE_RECT.bottom); ctx.stroke();
             
             ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 8;
             ctx.beginPath(); ctx.rect(0,0,TABLE_WIDTH, TABLE_HEIGHT); ctx.rect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
             ctx.clip('evenodd'); ctx.fillRect(0,0,TABLE_WIDTH, TABLE_HEIGHT); ctx.restore();
             
             POCKETS.forEach(p => {
                const g = ctx.createRadialGradient(p.x, p.y, POCKET_RADIUS*0.5, p.x, p.y, POCKET_RADIUS);
                g.addColorStop(0, '#111'); g.addColorStop(1, '#000');
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI*2); ctx.fill();
             });
        }

        function drawBall(ball, color) {
            ctx.save(); ctx.beginPath(); ctx.arc(ball.x + BALL_RADIUS*0.1, ball.y + BALL_RADIUS*0.15, BALL_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = BALL_RADIUS*0.3; ctx.fill(); ctx.restore();
            
            ctx.beginPath(); 
            const g = ctx.createRadialGradient(ball.x - BALL_RADIUS*0.3, ball.y - BALL_RADIUS*0.4, BALL_RADIUS*0.05, ball.x, ball.y, BALL_RADIUS);
            if(color==='#FFFFFF'){ g.addColorStop(0,'#FFF'); g.addColorStop(1,'#ccc'); } else { g.addColorStop(0,'#666'); g.addColorStop(1,'#000'); }
            ctx.fillStyle = g; ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2); ctx.fill();
        }
        function drawBlackBall() {
            drawBall(blackBall, '#000');
            ctx.beginPath(); ctx.arc(blackBall.x, blackBall.y, BALL_RADIUS*0.5, 0, Math.PI*2); ctx.fillStyle='#FFF'; ctx.fill();
            ctx.fillStyle='#000'; ctx.font=`bold ${BALL_RADIUS*0.75}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('8', blackBall.x, blackBall.y + BALL_RADIUS*0.05);
        }
        function drawSpinControl() {
            if(!canvasSpin.width) return;
            ctxSpin.clearRect(0,0,100,100);
            ctxSpin.save(); ctxSpin.beginPath(); ctxSpin.arc(spinBallControl.x+1, spinBallControl.y+2, spinBallControl.radius, 0, Math.PI*2);
            ctxSpin.fillStyle='rgba(0,0,0,0.2)'; ctxSpin.fill(); ctxSpin.restore();
            const g = ctxSpin.createRadialGradient(spinBallControl.x-12, spinBallControl.y-16, 2, spinBallControl.x, spinBallControl.y, 40);
            g.addColorStop(0,'#FFF'); g.addColorStop(1,'#ccc'); ctxSpin.fillStyle=g;
            ctxSpin.beginPath(); ctxSpin.arc(spinBallControl.x, spinBallControl.y, spinBallControl.radius, 0, Math.PI*2); ctxSpin.fill();
            ctxSpin.beginPath(); ctxSpin.arc(spinIndicator.x, spinIndicator.y, 5, 0, Math.PI*2);
            ctxSpin.fillStyle='rgba(220,38,38,0.9)'; ctxSpin.fill();
        }

        // --- LÓGICA FISICA (Simplificada para brevedad) ---
        function findWallCollision(pos, dir) {
            let tMin = Infinity, type = null;
            if(dir.x > 0.001) { let t = (PLAYABLE_RECT.right - BALL_RADIUS - pos.x)/dir.x; if(t>0 && t<tMin) {tMin=t; type='right';} }
            else if(dir.x < -0.001) { let t = (PLAYABLE_RECT.left + BALL_RADIUS - pos.x)/dir.x; if(t>0 && t<tMin) {tMin=t; type='left';} }
            if(dir.y > 0.001) { let t = (PLAYABLE_RECT.bottom - BALL_RADIUS - pos.y)/dir.y; if(t>0 && t<tMin) {tMin=t; type='bottom';} }
            else if(dir.y < -0.001) { let t = (PLAYABLE_RECT.top + BALL_RADIUS - pos.y)/dir.y; if(t>0 && t<tMin) {tMin=t; type='top';} }
            return {t:tMin, hitType:type};
        }
        function findBallCollision(pos, dir, target) {
            const v = {x:target.x-pos.x, y:target.y-pos.y};
            const dot = v.x*dir.x + v.y*dir.y; if(dot<=0) return {t:Infinity};
            const distSq = (v.x*v.x + v.y*v.y) - (dot*dot);
            const colRadSq = (BALL_RADIUS*2)**2;
            if(distSq >= colRadSq) return {t:Infinity};
            const t = dot - Math.sqrt(colRadSq - distSq);
            return {t: t>0 ? t : Infinity};
        }

        function drawFullTrajectory() {
            if ((gameState !== 'aiming' && gameState !== 'aimLocked') || !cueBall.active) return;
            let pos = {x:cueBall.x, y:cueBall.y}, dir = {...aimDir}, mag = Math.hypot(dir.x, dir.y);
            if(mag<0.01) return; dir.x/=mag; dir.y/=mag;
            
            let wall = findWallCollision(pos, dir);
            let ball = blackBall.active ? findBallCollision(pos, dir, blackBall) : {t:Infinity};
            let t = Math.min(wall.t, ball.t);
            if(t === Infinity || t > 2000) t = 2000;

            let hit = {x: pos.x + dir.x*t, y: pos.y + dir.y*t};
            
            ctx.beginPath(); ctx.moveTo(pos.x, pos.y); ctx.lineTo(hit.x, hit.y);
            ctx.strokeStyle = gameState==='aimLocked' ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.5)';
            ctx.setLineDash(gameState==='aimLocked' ? [] : [4,4]); ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);

            if(ball.t < wall.t && blackBall.active) {
                let bDir = {x:blackBall.x-hit.x, y:blackBall.y-hit.y}, bMag = Math.hypot(bDir.x, bDir.y);
                if(bMag>0.01) { bDir.x/=bMag; bDir.y/=bMag; drawPath(blackBall, bDir, 'rgba(255,255,0,0.6)'); }
                
                let tang = {x:-bDir.y, y:bDir.x}; 
                if(dir.x*tang.x + dir.y*tang.y < 0) { tang.x*=-1; tang.y*=-1; }
                
                // Aproximación efecto
                let follow = spinEffect.y < 0 ? -spinEffect.y : 0;
                let cDir = { x: bDir.x*follow + tang.x, y: bDir.y*follow + tang.y };
                let cMag = Math.hypot(cDir.x, cDir.y);
                if(cMag>0.01) { cDir.x/=cMag; cDir.y/=cMag; drawPath({x:hit.x-bDir.x*BALL_RADIUS, y:hit.y-bDir.y*BALL_RADIUS}, cDir, 'rgba(255,165,0,0.6)'); }
            } else if(isFinite(wall.t)) {
                 let nDir = {...dir}, spinX = spinEffect.x;
                 if(wall.hitType.match(/left|right/)) { nDir.x*=-1; nDir.y += spinX*0.4*(wall.hitType=='right'?-1:1)*Math.sign(nDir.y||1); }
                 else { nDir.y*=-1; nDir.x += spinX*0.4*(wall.hitType=='bottom'?1:-1)*Math.sign(nDir.x||1); }
                 let nMag = Math.hypot(nDir.x, nDir.y); if(nMag>0.01) { nDir.x/=nMag; nDir.y/=nMag; drawPath(hit, nDir, 'rgba(255,255,255,0.4)'); }
            }
        }
        function drawPath(pos, dir, color) {
            ctx.beginPath(); ctx.moveTo(pos.x, pos.y);
            let p = {...pos}, d = {...dir};
            for(let i=0; i<2; i++) {
                let w = findWallCollision(p, d); if(!isFinite(w.t)) break;
                let h = {x:p.x+d.x*w.t, y:p.y+d.y*w.t}; ctx.lineTo(h.x, h.y); p=h;
                if(w.hitType.match(/left|right/)) d.x*=-1; else d.y*=-1;
            }
            ctx.strokeStyle=color; ctx.stroke();
        }
        function drawPoolCue() {
            if(!cueBall.active) return;
            const ang = Math.atan2(aimDir.y, aimDir.x);
            let pull = powerBar.value * 2;
            ctx.save(); ctx.translate(cueBall.x, cueBall.y); ctx.rotate(ang);
            ctx.fillStyle='#d1ae74'; ctx.fillRect(-300-pull, -4, 280, 8);
            ctx.fillStyle='#fff'; ctx.fillRect(-20-pull, -4, 10, 8);
            ctx.restore();
        }
        function drawGhostBall() {
             if(gameState!=='aiming' || draggingBall) return;
             ctx.save(); ctx.globalAlpha=0.3; ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, BALL_RADIUS, 0, Math.PI*2);
             ctx.fillStyle='#fff'; ctx.fill(); ctx.restore();
        }

        // --- GAME LOOP & EVENTS ---
        function updatePhysics() {
            let moving = false;
            balls.forEach(b => { 
                if(b.active) { 
                    b.vx*=FRICTION; b.vy*=FRICTION; 
                    if(Math.hypot(b.vx, b.vy)<MIN_SPEED) {b.vx=0;b.vy=0;} else {b.x+=b.vx; b.y+=b.vy; moving=true;} 
                } 
            });
            
            // Simplificado colisiones
            balls.forEach(b => {
                if(!b.active || (b.vx==0 && b.vy==0)) return;
                POCKETS.forEach(p => { if(Math.hypot(b.x-p.x, b.y-p.y)<POCKET_RADIUS) { b.active=false; b.vx=0; b.vy=0; try{pocketSound.triggerAttackRelease("16n");}catch(e){} setTimeout(()=>{if(b==cueBall)resetToStartPositions(); else b.active=true;}, 500); } });
                
                if(b.x+BALL_RADIUS > PLAYABLE_RECT.right) { b.x=PLAYABLE_RECT.right-BALL_RADIUS; b.vx*=-RESTITUTION; }
                else if(b.x-BALL_RADIUS < PLAYABLE_RECT.left) { b.x=PLAYABLE_RECT.left+BALL_RADIUS; b.vx*=-RESTITUTION; }
                if(b.y+BALL_RADIUS > PLAYABLE_RECT.bottom) { b.y=PLAYABLE_RECT.bottom-BALL_RADIUS; b.vy*=-RESTITUTION; }
                else if(b.y-BALL_RADIUS < PLAYABLE_RECT.top) { b.y=PLAYABLE_RECT.top+BALL_RADIUS; b.vy*=-RESTITUTION; }
            });

            if(cueBall.active && blackBall.active) {
                 let dx=blackBall.x-cueBall.x, dy=blackBall.y-cueBall.y, dist=Math.hypot(dx,dy);
                 if(dist < BALL_RADIUS*2) {
                     try{ballCollisionSound.triggerAttackRelease("G4","16n");}catch(e){}
                     let nx=dx/dist, ny=dy/dist, p=2*(cueBall.vx*nx + cueBall.vy*ny - blackBall.vx*nx - blackBall.vy*ny)/2;
                     cueBall.vx -= p*nx; cueBall.vy -= p*ny; blackBall.vx += p*nx; blackBall.vy += p*ny;
                     let o = (BALL_RADIUS*2-dist)/2; cueBall.x-=o*nx; cueBall.y-=o*ny; blackBall.x+=o*nx; blackBall.y+=o*ny;
                 }
            }
            if(!moving) setTimeout(()=> { if(balls.every(b=>!b.active||(b.vx==0&&b.vy==0)) && gameState==='simulating') { gameState='aiming'; document.body.classList.remove('aim-locked'); } }, 100);
        }

        function gameLoop() {
            if(gameState==='simulating') updatePhysics();
            drawTable();
            if(gameState!=='simulating') { drawFullTrajectory(); drawPoolCue(); drawGhostBall(); }
            balls.forEach(b => { if(b.active) drawBall(b, b==cueBall?'#FFFFFF':'#000'); });
            if(blackBall.active) drawBlackBall();
            requestAnimationFrame(gameLoop);
        }

        // --- EVENTOS INTERFAZ ---
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            let cx = e.touches?e.touches[0].clientX:e.clientX, cy = e.touches?e.touches[0].clientY:e.clientY;
            return { x: (cx-r.left)*(canvas.width/r.width), y: (cy-r.top)*(canvas.height/r.height) };
        }
        canvas.addEventListener('mousedown', e => handleStart(e));
        canvas.addEventListener('touchstart', e => { handleStart(e); }, {passive:false});
        canvas.addEventListener('mousemove', e => handleMove(e));
        canvas.addEventListener('touchmove', e => { handleMove(e); }, {passive:false});
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        function handleStart(e) {
            startAudioContext();
            if(gameState==='simulating') return;
            let p = getPos(e); if(!p) return; mousePos = p;
            let dC = Math.hypot(p.x-cueBall.x, p.y-cueBall.y);
            if(dC < BALL_RADIUS*2) draggingBall = cueBall;
            else if(isTouchDevice && gameState==='aiming') { /* solo mover */ } 
            else if(!isTouchDevice && gameState==='aiming') { gameState='aimLocked'; document.body.classList.add('aim-locked'); updateAim(p); }
            else if(gameState==='aimLocked') { gameState='aiming'; document.body.classList.remove('aim-locked'); }
        }
        function handleMove(e) {
            let p = getPos(e); if(!p) return; mousePos = p;
            if(draggingBall) { draggingBall.x=p.x; draggingBall.y=p.y; e.preventDefault(); }
            else if(cueBall.active && (isTouchDevice || gameState==='aiming')) { updateAim(p); if(e.type=='touchmove') e.preventDefault(); }
        }
        function handleEnd() {
            if(isTouchDevice && !draggingBall && gameState==='aiming') { gameState='aimLocked'; document.body.classList.add('aim-locked'); }
            draggingBall = null; isSettingSpin=false;
        }
        function updateAim(p) {
            let dx=p.x-cueBall.x, dy=p.y-cueBall.y, m=Math.hypot(dx,dy);
            if(m>0.1) { aimDir.x=dx/m; aimDir.y=dy/m; }
        }

        // --- SPINNER ---
        function setSpin(e) {
            const r = canvasSpin.getBoundingClientRect();
            let cx = e.touches?e.touches[0].clientX:e.clientX, cy = e.touches?e.touches[0].clientY:e.clientY;
            let dx = cx-r.left-50, dy = cy-r.top-50, d=Math.hypot(dx,dy);
            if(d>40) { let a=Math.atan2(dy,dx); dx=Math.cos(a)*40; dy=Math.sin(a)*40; }
            spinIndicator = {x:50+dx, y:50+dy}; spinEffect = {x:dx/40, y:dy/40}; drawSpinControl();
        }
        ['mousedown','mousemove','touchstart','touchmove'].forEach(ev => canvasSpin.addEventListener(ev, e => { if(ev.match(/start|down/)) isSettingSpin=true; if(isSettingSpin) { e.preventDefault(); setSpin(e); } }, {passive:false}));
        ['mouseup','touchend'].forEach(ev => window.addEventListener(ev, () => isSettingSpin=false));

        // --- DISPARO ---
        powerBar.addEventListener('input', () => { if(gameState==='aiming'||gameState==='aimLocked') drawPoolCue(); });
        ['mouseup','touchend'].forEach(ev => powerBar.addEventListener(ev, () => {
            let v = parseInt(powerBar.value); powerBar.value=0;
            if(v>5 && cueBall.active && (gameState==='aiming'||gameState==='aimLocked')) {
                gameState='simulating'; document.body.classList.remove('aim-locked');
                cueBall.vx = aimDir.x * v * POWER_MULTIPLIER; cueBall.vy = aimDir.y * v * POWER_MULTIPLIER;
                try{ cueHitSound.triggerAttackRelease("C3","8n"); }catch(e){}
            }
        }));

        resetButton.addEventListener('click', () => { startAudioContext(); restoreLastPositions(); });

        // --- PANTALLA COMPLETA ROBUSTA ---
        const appEl = document.documentElement;
        const fullBtn = document.getElementById('fullscreenButton');
        
        // Función Toggle mejorada para fallbacks
        async function toggleFullScreen() {
            try {
                // 1. Si ya estamos en fullscreen (nativo o falso), salir.
                const isNativeFull = document.fullscreenElement || document.webkitFullscreenElement;
                const isFakeFull = document.body.classList.contains('maximize-area');

                if (isNativeFull) {
                    if (document.exitFullscreen) await document.exitFullscreen();
                    else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
                } else if (isFakeFull) {
                    // Salir del modo falso
                    document.body.classList.remove('maximize-area');
                    setTimeout(setupCanvas, 100);
                } else {
                    // 2. Intentar entrar
                    // Primero probamos API nativa
                    if (appEl.requestFullscreen) await appEl.requestFullscreen();
                    else if (appEl.webkitRequestFullscreen) await appEl.webkitRequestFullscreen();
                    else {
                        // Si no existe API (ej. iPhone), lanzamos error para ir al catch
                        throw new Error("API no soportada");
                    }
                }
            } catch (err) {
                console.log("Usando fallback CSS fullscreen");
                // Fallback: Toggle clase CSS forzada
                document.body.classList.toggle('maximize-area');
                setTimeout(setupCanvas, 100);
            }
        }

        // Listener para cambios nativos (tecla Esc, gesto del sistema)
        function onFullChange() {
            const isFull = !!(document.fullscreenElement || document.webkitFullscreenElement);
            if (isFull) document.body.classList.add('maximize-area');
            else if (!document.body.style.position) document.body.classList.remove('maximize-area'); // Solo quitar si no forzamos
            setTimeout(setupCanvas, 200);
        }
        document.addEventListener('fullscreenchange', onFullChange);
        document.addEventListener('webkitfullscreenchange', onFullChange);

        fullBtn.addEventListener('click', () => { startAudioContext(); toggleFullScreen(); });

        // Init
        setupSpinControl();
        gameLoop();
        setupCanvas();
    </script>
</body>
</html>
