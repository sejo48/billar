<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Trayectoria de Billar</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Librería de Sonido (Tone.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo para la fuente Inter */
        html, body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevenir scroll en la página */
            height: 100%;
        }
        /* Asegura que el canvas tenga un fondo, en caso de que tailwind no cargue */
        canvas {
            background-color: #059669; /* Verde billar */
            display: block; /* Evita espacios extra */
            cursor: none; /* Oculta el cursor del ratón */
        }
        /* Estilo para la fuente elegante */
        .elegant-script {
            font-family: 'Dancing Script', cursive;
        }
        /* Oculta el botón de fullscreen en PC (donde no es tan necesario) */
        #fullscreen-btn {
            display: none;
        }
        /* Muestra el botón de fullscreen solo en pantallas táctiles (móviles/tablets) */
        @media (pointer: coarse) {
            #fullscreen-btn {
                display: block;
            }
        }
        /* Oculta el botón de fullscreen cuando YA estamos en modo fullscreen */
        :fullscreen #fullscreen-btn {
            display: none;
        }
        /* Asegura que el contenedor principal ocupe toda la altura */
        .main-container {
            height: 100vh; /* Ocupa toda la altura de la vista */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<!-- 
    Lógica de padding para orientación.
    - Teléfono vertical: p-4 (padding 4)
    - Teléfono horizontal: landscape:p-0 (sin padding)
    - PC/Tablet: md:p-4 (padding 4)
-->
<body class="bg-gray-900 text-gray-100 flex flex-col items-center p-4 landscape:p-0 md:p-4 md:justify-center min-h-screen">

    <div class="w-full max-w-5xl main-container">
        
        <!-- 
            Lógica de visualización para orientación.
            - Teléfono vertical: "flex" (visible)
            - Teléfono horizontal: "landscape:hidden" (oculto)
            - PC/Tablet: "md:flex" (visible, anula el landscape:hidden)
        -->
        <div class="flex landscape:hidden md:flex justify-between items-start mb-2 px-4 md:px-0 w-full">
            <div>
                <h1 class="text-3xl font-bold text-left mb-2">Simulador de Billar</h1>
                <p class="text-left text-gray-300 mb-4">
                    Apunta con el ratón. Clica y arrastra hacia atrás para disparar.
                </p>
            </div>
            
            <div class="flex-shrink-0 flex flex-col items-center p-2 rounded-lg bg-gray-800 shadow-lg border border-gray-700">
                <canvas id="spinControlCanvas"></canvas>
                <span class="text-sm text-gray-400 mt-1">Control de Efecto</span>
            </div>
        </div>

        <!-- Esta es la mesa de juego, siempre visible -->
        <div class="relative aspect-[2/1] w-full bg-yellow-900 border-8 border-yellow-800 rounded-lg shadow-2xl overflow-hidden">
            <canvas id="poolTable"></canvas>
            
            <!-- NUEVO: Botón de Pantalla Completa -->
            <button id="fullscreen-btn" class="absolute bottom-2 right-2 p-2 rounded-full bg-gray-900 bg-opacity-50 text-white hover:bg-opacity-75 transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrows-fullscreen" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M5.828 10.172a.5.5 0 0 0-.707 0l-4 4a.5.5 0 0 0 0 .707l4 4a.5.5 0 0 0 .707-.707L2.707 11H7.5a.5.5 0 0 0 0-1H2.707l3.121-3.121a.5.5 0 0 0 0-.707zM10.172 5.828a.5.5 0 0 0 0 .707l3.121 3.121H8.5a.5.5 0 0 0 0 1H13.293l-3.121 3.121a.5.5 0 0 0 .707.707l4-4a.5.5 0 0 0 0-.707l-4-4a.5.5 0 0 0-.707 0zM.5 1a.5.5 0 0 0 0 1h4.793L1.146 6.146a.5.5 0 0 0 .708.708L6 2.707V7.5a.5.5 0 0 0 1 0V1H.5zM10 8.5a.5.5 0 0 0-1 0v4.793l-4.146-4.147a.5.5 0 0 0-.708.708L8.293 14H3.5a.5.5 0 0 0 0 1h5.5V8.5z"/>
                </svg>
            </button>
        </div>

        <!-- 
            Lógica de visualización para orientación (igual que el bloque superior).
        -->
        <div class="flex landscape:hidden md:flex text-center mt-4 flex-col items-center px-4 md:px-0">
            <button id="resetButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 shadow-lg mb-4">
                Reiniciar Posiciones
            </button>
            
            <p class="elegant-script text-2xl text-gray-400">
                Aplicación hecha por Jorge Hernández
            </p>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACIÓN INICIAL ---
        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const fullscreenButton = document.getElementById('fullscreen-btn');
        
        const canvasSpin = document.getElementById('spinControlCanvas');
        const ctxSpin = canvasSpin.getContext('2d');

        // --- 2. ESTADO DE LA SIMULACIÓN ---
        let cueBall = { 
            x: 0, y: 0, 
            vx: 0, vy: 0,
            active: true 
        };
        let blackBall = { 
            x: 0, y: 0, 
            vx: 0, vy: 0,
            active: true 
        };
        let balls = [cueBall, blackBall];

        let mousePos = { x: 0, y: 0 };
        let draggingBall = null; 
        let isSettingSpin = false; 
        
        let gameState = 'aiming'; // 'aiming', 'pulling', 'simulating'
        let pullStartPos = null;  
        let pullEndPos = null;    
        let aimDir = { x: 1, y: 0 }; 

        let spinEffect = { x: 0, y: 0 }; 
        let spinBallControl = { x: 0, y: 0, radius: 0 };
        let spinIndicator = { x: 0, y: 0 }; 

        // --- 3. CONSTANTES DE FÍSICA Y MESA ---
        let TABLE_WIDTH, TABLE_HEIGHT;
        let CUSHION_SIZE;
        let BALL_RADIUS;
        let POCKET_RADIUS;
        let POCKETS = [];
        let PLAYABLE_RECT = {}; 
        
        const FRICTION = 0.985; 
        const MIN_SPEED = 0.05; 
        const SPIN_FACTOR_CUSHION = 0.4; 
        const POWER_MULTIPLIER = 0.2; 

        // --- 4. SONIDOS (Tone.js) ---
        let soundsReady = false;
        let cueHitSound, ballCollisionSound, cushionHitSound, pocketSound;

        function initSounds() {
            if (soundsReady) return;
            
            cueHitSound = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 2,
                envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 }
            }).toDestination();

            ballCollisionSound = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 5,
                envelope: { attack: 0.001, decay: 0.15, sustain: 0.01, release: 0.1 }
            }).toDestination();
            ballCollisionSound.volume.value = -6;

            cushionHitSound = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 1,
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }
            }).toDestination();
            cushionHitSound.volume.value = -12;

            pocketSound = new Tone.NoiseSynth({
                noise: { type: 'brown' },
                envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 }
            }).toDestination();
            pocketSound.volume.value = -6;

            soundsReady = true;
        }

        async function startAudioContext() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            initSounds(); 
        }


        /**
         * setupCanvas()
         * Configura las dimensiones del canvas y todas las constantes relativas.
         */
        function setupCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            TABLE_WIDTH = canvas.width;
            TABLE_HEIGHT = canvas.height;

            CUSHION_SIZE = TABLE_WIDTH * 0.045; 
            BALL_RADIUS = TABLE_WIDTH * 0.015;
            POCKET_RADIUS = BALL_RADIUS * 1.8; 

            PLAYABLE_RECT = {
                left: CUSHION_SIZE,
                top: CUSHION_SIZE,
                width: TABLE_WIDTH - 2 * CUSHION_SIZE,
                height: TABLE_HEIGHT - 2 * CUSHION_SIZE,
                right: TABLE_WIDTH - CUSHION_SIZE,
                bottom: TABLE_HEIGHT - CUSHION_SIZE
            };
            
            POCKETS = [
                { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.top }, 
                { x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.top },   
                { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.top }, 
                { x: PLAYABLE_RECT.left, y: PLAYABLE_RECT.bottom },
                { x: TABLE_WIDTH / 2, y: PLAYABLE_RECT.bottom }, 
                { x: PLAYABLE_RECT.right, y: PLAYABLE_RECT.bottom } 
            ];

            if (!draggingBall && gameState !== 'simulating') {
                resetBalls();
            }
        }

        function resetBalls() {
            gameState = 'aiming'; 
            
            cueBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.25;
            cueBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            cueBall.vx = 0; cueBall.vy = 0; cueBall.active = true;

            blackBall.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.7;
            blackBall.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
            blackBall.vx = 0; blackBall.vy = 0; blackBall.active = true;

            balls = [cueBall, blackBall]; 

            spinEffect.x = 0; spinEffect.y = 0;
            spinIndicator.x = spinBallControl.x;
            spinIndicator.y = spinBallControl.y;
            
            drawSpinControl();
        }

        // --- 5. FUNCIONES DE DIBUJO ---

        function drawTable() {
            ctx.clearRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            const woodGradient = ctx.createLinearGradient(0, 0, 0, TABLE_HEIGHT);
            woodGradient.addColorStop(0, '#6b2112'); 
            woodGradient.addColorStop(0.5, '#a1331d'); 
            woodGradient.addColorStop(1, '#6b2112'); 
            ctx.fillStyle = woodGradient; 
            ctx.fillRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            const diamondRadius = CUSHION_SIZE * 0.18; 
            const playableWidth = PLAYABLE_RECT.width;
            const playableHeight = PLAYABLE_RECT.height;
            const segmentX = playableWidth / 8; 
            const segmentY = playableHeight / 4; 
            const topRailY = PLAYABLE_RECT.top / 2;
            const bottomRailY = PLAYABLE_RECT.bottom + CUSHION_SIZE / 2;
            const leftRailX = PLAYABLE_RECT.left / 2;
            const rightRailX = PLAYABLE_RECT.right + CUSHION_SIZE / 2;

            const drawDiamond = (x, y) => {
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 2;
                ctx.shadowOffsetY = 1;
                const diamondGradient = ctx.createRadialGradient(x, y - 1, 0, x, y, diamondRadius);
                diamondGradient.addColorStop(0, '#FFFFFF'); 
                diamondGradient.addColorStop(1, '#e0e0e0'); 
                ctx.fillStyle = diamondGradient;
                ctx.beginPath();
                ctx.arc(x, y, diamondRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); 
            };

            for (let i = 1; i <= 7; i++) {
                const x = PLAYABLE_RECT.left + (segmentX * i);
                drawDiamond(x, topRailY);
                drawDiamond(x, bottomRailY);
            }
            for (let i = 1; i <= 3; i++) {
                const y = PLAYABLE_RECT.top + (segmentY * i);
                drawDiamond(leftRailX, y);
                drawDiamond(rightRailX, y);
            }

            ctx.fillStyle = '#059669'; 
            ctx.fillRect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
            
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.rect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);
            ctx.rect(PLAYABLE_RECT.left, PLAYABLE_RECT.top, PLAYABLE_RECT.width, PLAYABLE_RECT.height);
            ctx.clip('evenodd'); 
            ctx.fillRect(PLAYABLE_RECT.left - 10, PLAYABLE_RECT.top - 10, PLAYABLE_RECT.width + 20, PLAYABLE_RECT.height + 20);
            ctx.restore();

            POCKETS.forEach(pocket => {
                const pocketGradient = ctx.createRadialGradient(pocket.x, pocket.y, POCKET_RADIUS * 0.5, pocket.x, pocket.y, POCKET_RADIUS);
                pocketGradient.addColorStop(0, '#111111'); 
                pocketGradient.addColorStop(1, '#000000'); 
                ctx.fillStyle = pocketGradient; 
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, POCKET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBall(ball, color) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(ball.x + 2, ball.y + 3, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetY = 2;
            ctx.fill();
            ctx.restore();

            ctx.beginPath();
            const highlightX = ball.x - BALL_RADIUS * 0.3;
            const highlightY = ball.y - BALL_RADIUS * 0.3;
            const gradient = ctx.createRadialGradient(highlightX, highlightY, BALL_RADIUS * 0.1, ball.x, ball.y, BALL_RADIUS);
            
            if (color === '#FFFFFF') {
                gradient.addColorStop(0, '#FFFFFF'); 
                gradient.addColorStop(0.8, '#e0e0e0'); 
                gradient.addColorStop(1, '#bbbbbb'); 
            } else { 
                gradient.addColorStop(0, '#555555'); 
                gradient.addColorStop(0.8, '#1a1a1a'); 
                gradient.addColorStop(1, '#000000'); 
            }

            ctx.fillStyle = gradient;
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBlackBall() {
            drawBall(blackBall, '#000000');

            ctx.beginPath();
            ctx.arc(blackBall.x, blackBall.y, BALL_RADIUS * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetY = 1;
            ctx.fill();
            ctx.shadowColor = 'transparent'; 

            ctx.fillStyle = '#000000';
            ctx.font = `bold ${BALL_RADIUS * 0.9}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('8', blackBall.x, blackBall.y + 1);
        }

        function drawSpinControl() {
            ctxSpin.clearRect(0, 0, canvasSpin.width, canvasSpin.height);
            
            ctxSpin.save();
            ctxSpin.beginPath();
            ctxSpin.arc(spinBallControl.x + 2, spinBallControl.y + 3, spinBallControl.radius, 0, Math.PI * 2);
            ctxSpin.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctxSpin.shadowColor = 'rgba(0, 0, 0, 0.25)';
            ctxSpin.shadowBlur = 5;
            ctxSpin.shadowOffsetY = 2;
            ctxSpin.fill();
            ctxSpin.restore();

            ctxSpin.beginPath();
            const highlightX = spinBallControl.x - spinBallControl.radius * 0.3;
            const highlightY = spinBallControl.y - spinBallControl.radius * 0.3;
            const gradient = ctxSpin.createRadialGradient(highlightX, highlightY, spinBallControl.radius * 0.1, spinBallControl.x, spinBallControl.y, spinBallControl.radius);
            gradient.addColorStop(0, '#FFFFFF');
            gradient.addColorStop(0.8, '#e0e0e0');
            gradient.addColorStop(1, '#bbbbbb');
            ctxSpin.fillStyle = gradient;
            ctxSpin.arc(spinBallControl.x, spinBallControl.y, spinBallControl.radius, 0, Math.PI * 2);
            ctxSpin.fill();

            ctxSpin.beginPath();
            ctxSpin.arc(spinIndicator.x, spinIndicator.y, spinBallControl.radius * 0.15, 0, Math.PI * 2);
            ctxSpin.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctxSpin.strokeStyle = 'rgba(100, 0, 0, 0.8)';
            ctxSpin.lineWidth = 2;
            ctxSpin.fill();
            ctxSpin.stroke();
        }

        // --- 6. LÓGICA DE TRAYECTORIA Y GOLPE ---

        function findWallCollision(startPos, dir) {
            let tMin = Infinity;
            let hitType = null;
            
            if (dir.x > 0) {
                let t = (PLAYABLE_RECT.right - startPos.x) / dir.x;
                if (t > 0 && t < tMin) { tMin = t; hitType = 'right'; }
            } else if (dir.x < 0) {
                let t = (PLAYABLE_RECT.left - startPos.x) / dir.x;
                if (t > 0 && t < tMin) { tMin = t; hitType = 'left'; }
            }
            if (dir.y > 0) {
                let t = (PLAYABLE_RECT.bottom - startPos.y) / dir.y;
                if (t > 0 && t < tMin) { tMin = t; hitType = 'bottom'; }
            } else if (dir.y < 0) {
                let t = (PLAYABLE_RECT.top - startPos.y) / dir.y;
                if (t > 0 && t < tMin) { tMin = t; hitType = 'top'; }
            }
            return { t: tMin, hitType: hitType };
        }

        function findBallCollision(startPos, dir, targetBall) {
            const collisionRadius = BALL_RADIUS * 2; 
            const v = { x: targetBall.x - startPos.x, y: targetBall.y - startPos.y };
            
            const t_proj = v.x * dir.x + v.y * dir.y;
            if (t_proj <= 0) return { t: Infinity };

            const closestPoint = {
                x: startPos.x + dir.x * t_proj,
                y: startPos.y + dir.y * t_proj
            };
            
            const distSqr = (targetBall.x - closestPoint.x) ** 2 + (targetBall.y - closestPoint.y) ** 2;
            const collisionRadiusSqr = collisionRadius ** 2;

            if (distSqr >= collisionRadiusSqr) return { t: Infinity };

            const thc = Math.sqrt(collisionRadiusSqr - distSqr);
            const t_hit = t_proj - thc; 

            if (t_hit < 0) return { t: Infinity };

            return { t: t_hit };
        }

        function drawFullTrajectory() {
            if (gameState === 'simulating' || !cueBall.active) return; 

            let startPos = { x: cueBall.x, y: cueBall.y };
            let dir = aimDir;
            
            const mag = Math.hypot(mousePos.x - startPos.x, mousePos.y - startPos.y);
            if (mag < BALL_RADIUS) return; 

            const wallHit = findWallCollision(startPos, dir);
            const ballHit = blackBall.active ? findBallCollision(startPos, dir, blackBall) : { t: Infinity };

            if (ballHit.t < wallHit.t) {
                const cueHitPoint = {
                    x: startPos.x + dir.x * ballHit.t,
                    y: startPos.y + dir.y * ballHit.t
                };
                ctx.beginPath();
                ctx.moveTo(startPos.x, startPos.y);
                ctx.lineTo(cueHitPoint.x, cueHitPoint.y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();

                let blackBallDir = {
                    x: blackBall.x - cueHitPoint.x,
                    y: blackBall.y - cueHitPoint.y
                };
                const blackMag = Math.hypot(blackBallDir.x, blackBallDir.y);
                blackBallDir.x /= blackMag;
                blackBallDir.y /= blackMag;

                drawPath(blackBall, blackBallDir, 'rgba(255, 255, 0, 0.7)', 4, {x: 0, y: 0}); 

                let stunDir = { x: -blackBallDir.y, y: blackBallDir.x };
                if (dir.x * stunDir.x + dir.y * stunDir.y < 0) {
                    stunDir.x *= -1;
                    stunDir.y *= -1;
                }
                let followDir = blackBallDir;
                let drawDir = { x: -blackBallDir.x, y: -blackBallDir.y };
                
                const stunAmount = 1 - Math.abs(spinEffect.y);
                const followAmount = spinEffect.y < 0 ? -spinEffect.y : 0; 
                const drawAmount = spinEffect.y > 0 ? spinEffect.y : 0;   

                let cueAfterHitDir = {
                    x: (stunDir.x * stunAmount) + (followDir.x * followAmount) + (drawDir.x * drawAmount),
                    y: (stunDir.y * stunAmount) + (followDir.y * followAmount) + (drawDir.y * drawAmount)
                };

                const cueAfterMag = Math.hypot(cueAfterHitDir.x, cueAfterHitDir.y);
                
                if (cueAfterMag > 0.01) {
                    cueAfterHitDir.x /= cueAfterMag;
                    cueAfterHitDir.y /= cueAfterMag;
                    drawPath(cueHitPoint, cueAfterHitDir, 'rgba(255, 165, 0, 0.7)', 4, spinEffect); 
                }
                
            } else {
                drawPath(startPos, dir, 'rgba(255, 255, 255, 0.7)', 4, spinEffect); 
            }

            ctx.setLineDash([]); 
        }
        
        function drawPath(startPos, dir, color, maxBounces = 6, spin = {x: 0, y: 0}) {
            let currentPos = { ...startPos };
            let currentDir = { ...dir };
            
            ctx.beginPath();
            ctx.moveTo(currentPos.x, currentPos.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            for (let i = 0; i < maxBounces; i++) { 
                const wallHit = findWallCollision(currentPos, currentDir);
                if (wallHit.t === Infinity) break;
                const hitPoint = {
                    x: currentPos.x + currentDir.x * wallHit.t,
                    y: currentPos.y + currentDir.y * wallHit.t
                };
                ctx.lineTo(hitPoint.x, hitPoint.y);

                let isPocketed = false;
                for (const pocket of POCKETS) {
                    if (Math.hypot(hitPoint.x - pocket.x, hitPoint.y - pocket.y) < POCKET_RADIUS) {
                        isPocketed = true;
                        break;
                    }
                }
                if (isPocketed) break;

                currentPos = hitPoint;
                if (wallHit.hitType === 'left' || wallHit.hitType === 'right') {
                    currentDir.x = -currentDir.x;
                    currentDir.y += spin.x * (currentDir.x > 0 ? -1 : 1) * SPIN_FACTOR_CUSHION;
                }
                if (wallHit.hitType === 'top' || wallHit.hitType === 'bottom') {
                    currentDir.y = -currentDir.y;
                    currentDir.x += spin.x * (currentDir.y > 0 ? 1 : -1) * SPIN_FACTOR_CUSHION;
                }

                const mag = Math.hypot(currentDir.x, currentDir.y);
                if (mag > 0) {
                    currentDir.x /= mag;
                    currentDir.y /= mag;
                }
            }
            ctx.stroke();
        }

        function drawPoolCue() {
            if (!cueBall.active) return;
            
            const angle = Math.atan2(aimDir.y, aimDir.x);
            
            let pullBack = 0; 
            if (gameState === 'pulling') {
                const pullDist = Math.hypot(pullEndPos.x - pullStartPos.x, pullEndPos.y - pullStartPos.y);
                pullBack = Math.min(pullDist, TABLE_WIDTH * 0.2); 
            }

            ctx.save();
            ctx.translate(cueBall.x, cueBall.y);
            ctx.rotate(angle);

            const cueStartX = -BALL_RADIUS * 1.5 - pullBack;
            const cueLength = TABLE_WIDTH * 0.4;
            const cueTipWidth = BALL_RADIUS * 0.15;
            const cueButtWidth = BALL_RADIUS * 0.35;

            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 5;
            
            const gripLength = cueLength * 0.4;
            ctx.beginPath();
            ctx.moveTo(cueStartX - cueLength, -cueButtWidth);
            ctx.lineTo(cueStartX - cueLength + gripLength, -cueButtWidth * 0.8);
            ctx.lineTo(cueStartX - cueLength + gripLength, cueButtWidth * 0.8);
            ctx.lineTo(cueStartX - cueLength, cueButtWidth);
            ctx.closePath();
            ctx.fillStyle = '#3a2e28'; 
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cueStartX - cueLength + gripLength, -cueButtWidth * 0.8);
            ctx.lineTo(cueStartX, -cueTipWidth);
            ctx.lineTo(cueStartX, cueTipWidth);
            ctx.lineTo(cueStartX - cueLength + gripLength, cueButtWidth * 0.8);
            ctx.closePath();
            const woodGradient = ctx.createLinearGradient(cueStartX - cueLength, 0, cueStartX, 0);
            woodGradient.addColorStop(0, '#f2d1a3'); 
            woodGradient.addColorStop(1, '#e3b778');
            ctx.fillStyle = woodGradient;
            ctx.fill();
            
            ctx.beginPath();
            ctx.rect(cueStartX, -cueTipWidth, BALL_RADIUS * 0.3, cueTipWidth * 2);
            ctx.fillStyle = '#ffffff'; 
            ctx.fill();
            
            ctx.beginPath();
            ctx.rect(cueStartX + BALL_RADIUS * 0.3, -cueTipWidth, BALL_RADIUS * 0.1, cueTipWidth * 2);
            ctx.fillStyle = '#4a2c2c'; 
            ctx.fill();

            ctx.restore(); 
        }

        function drawGhostBall() {
            if (gameState !== 'aiming' || !mousePos.x) return;
            if (gameState === 'pulling') return;

            ctx.save();
            ctx.beginPath();
            ctx.arc(mousePos.x, mousePos.y, BALL_RADIUS, 0, Math.PI * 2);
            
            const gradient = ctx.createRadialGradient(
                mousePos.x - BALL_RADIUS * 0.3, 
                mousePos.y - BALL_RADIUS * 0.3, 
                BALL_RADIUS * 0.1, 
                mousePos.x, 
                mousePos.y, 
                BALL_RADIUS
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            gradient.addColorStop(0.8, 'rgba(224, 224, 224, 0.5)');
            gradient.addColorStop(1, 'rgba(187, 187, 187, 0.5)');

            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.6; 
            ctx.fill();
            ctx.restore();
        }


        // --- 7. MOTOR DE FÍSICA (SIMULACIÓN) ---

        function updatePhysics() {
            if (gameState !== 'simulating') return;

            let ballsStillMoving = false;

            for (const ball of balls) {
                if (!ball.active) continue;

                ball.vx *= FRICTION;
                ball.vy *= FRICTION;

                if (Math.hypot(ball.vx, ball.vy) < MIN_SPEED) {
                    ball.vx = 0;
                    ball.vy = 0;
                } else {
                    ball.x += ball.vx;
                    ball.y += ball.vy;
                    ballsStillMoving = true;
                }
            }

            for (const ball of balls) {
                if (!ball.active || (ball.vx === 0 && ball.vy === 0)) continue;

                let isPocketed = false;
                for (const pocket of POCKETS) {
                    if (Math.hypot(ball.x - pocket.x, ball.y - pocket.y) < POCKET_RADIUS) { 
                        ball.active = false;
                        ball.vx = 0;
                        ball.vy = 0;
                        isPocketed = true;
                        
                        if (soundsReady) {
                            pocketSound.triggerAttackRelease("16n");
                        }
                        
                        setTimeout(() => {
                            if (ball === cueBall) {
                                ball.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.25;
                                ball.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
                            } else {
                                ball.x = PLAYABLE_RECT.left + PLAYABLE_RECT.width * 0.7;
                                ball.y = PLAYABLE_RECT.top + PLAYABLE_RECT.height / 2;
                            }
                            ball.active = true;
                        }, 1000); 
                        break; 
                    }
                }
                
                if (!isPocketed) {
                    let hit = false;
                    if (ball.x + BALL_RADIUS > PLAYABLE_RECT.right) {
                        ball.x = PLAYABLE_RECT.right - BALL_RADIUS;
                        ball.vx = -ball.vx;
                        ball.vy += spinEffect.x * (ball.vx > 0 ? -1 : 1) * SPIN_FACTOR_CUSHION * Math.abs(ball.vx);
                        hit = true;
                    } else if (ball.x - BALL_RADIUS < PLAYABLE_RECT.left) {
                        ball.x = PLAYABLE_RECT.left + BALL_RADIUS;
                        ball.vx = -ball.vx;
                        ball.vy += spinEffect.x * (ball.vx > 0 ? -1 : 1) * SPIN_FACTOR_CUSHION * Math.abs(ball.vx);
                        hit = true;
                    }
                    
                    if (ball.y + BALL_RADIUS > PLAYABLE_RECT.bottom) {
                        ball.y = PLAYABLE_RECT.bottom - BALL_RADIUS;
                        ball.vy = -ball.vy;
                        ball.vx += spinEffect.x * (ball.vy > 0 ? 1 : -1) * SPIN_FACTOR_CUSHION * Math.abs(ball.vy);
                        hit = true;
                    } else if (ball.y - BALL_RADIUS < PLAYABLE_RECT.top) {
                        ball.y = PLAYABLE_RECT.top + BALL_RADIUS;
                        ball.vy = -ball.vy;
                        ball.vx += spinEffect.x * (ball.vy > 0 ? 1 : -1) * SPIN_FACTOR_CUSHION * Math.abs(ball.vy);
                        hit = true;
                    }
                    
                    if (hit) {
                        if (soundsReady) {
                            const hitVelocity = Math.min(Math.hypot(ball.vx, ball.vy) / 10, 1);
                            cushionHitSound.triggerAttackRelease("C2", "16n", Tone.now(), hitVelocity);
                        }
                        if (ball === cueBall) {
                            spinEffect.y = 0; 
                        }
                    }
                }
            }
            
            if (cueBall.active && blackBall.active) {
                const dx = blackBall.x - cueBall.x;
                const dy = blackBall.y - cueBall.y;
                const dist = Math.hypot(dx, dy);
                const collisionDist = BALL_RADIUS * 2;

                if (dist < collisionDist) {
                    
                    if (soundsReady) {
                        const hitVelocity = Math.min(Math.hypot(cueBall.vx, cueBall.vy) / 15, 1);
                        ballCollisionSound.triggerAttackRelease("G4", "16n", Tone.now(), hitVelocity);
                    }

                    const nx = dx / dist; 
                    const ny = dy / dist; 
                    const tx = -ny; 
                    const ty = nx;  

                    const v1n = cueBall.vx * nx + cueBall.vy * ny;
                    const v1t = cueBall.vx * tx + cueBall.vy * ty;
                    const v2n = blackBall.vx * nx + blackBall.vy * ny;
                    const v2t = blackBall.vx * tx + blackBall.vy * ty;

                    const v1n_new = v2n;
                    const v2n_new = v1n;

                    const stunAmount = 1 - Math.abs(spinEffect.y);
                    const followAmount = spinEffect.y < 0 ? -spinEffect.y : 0; 
                    const drawAmount = spinEffect.y > 0 ? spinEffect.y : 0; 
                    
                    let new_v1t = v1t;
                    let new_v1n = (v1n * -drawAmount) + (v1n * followAmount) + (v1n_new * stunAmount);

                    cueBall.vx = new_v1n * nx + new_v1t * tx;
                    cueBall.vy = new_v1n * ny + new_v1t * ty;
                    blackBall.vx = v2n_new * nx + v2t * tx;
                    blackBall.vy = v2n_new * ny + v2t * ty;
                    
                    const overlap = collisionDist - dist;
                    cueBall.x -= overlap * nx * 0.5;
                    cueBall.y -= overlap * ny * 0.5;
                    blackBall.x += overlap * nx * 0.5;
                    blackBall.y += overlap * ny * 0.5;

                    spinEffect.y = 0; 
                }
            }

            if (!ballsStillMoving) {
                gameState = 'aiming';
            }
        }
        
        // --- 8. BUCLE PRINCIPAL DE ANIMACIÓN ---

        function gameLoop() {
            if (gameState === 'simulating') {
                updatePhysics();
            }

            drawTable();

            // CORRECCIÓN: Dibujar líneas de trayectoria también en estado 'pulling'
            if (gameState === 'aiming' || gameState === 'pulling') { 
                drawFullTrajectory(); 
                drawPoolCue(); 
            }
            
            if (gameState === 'aiming') {
                drawGhostBall(); 
            }
            
            if (cueBall.active) drawBall(cueBall, '#FFFFFF'); 
            if (blackBall.active) drawBlackBall(); 
            
            requestAnimationFrame(gameLoop);
        }

        // --- 9. MANEJADORES DE EVENTOS ---

        function getMousePosInCanvas(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX = event.clientX;
            let clientY = event.clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        function getMousePosInSpinCanvas(event) {
            const rect = canvasSpin.getBoundingClientRect();
            const scaleX = canvasSpin.width / rect.width;
            const scaleY = canvasSpin.height / rect.height;
            let clientX = event.clientX;
            let clientY = event.clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }

        function handleDragStart(event) {
            startAudioContext(); 
            
            if (gameState === 'simulating') return;
            
            const pos = getMousePosInCanvas(event);

            const distCue = Math.hypot(pos.x - cueBall.x, pos.y - cueBall.y);
            const distBlack = Math.hypot(pos.x - blackBall.x, pos.y - blackBall.y);
            const grabRadius = BALL_RADIUS * 1.5;

            if (gameState === 'aiming' && cueBall.active && distCue < grabRadius) {
                draggingBall = 'cue';
            } else if (gameState === 'aiming' && blackBall.active && distBlack < grabRadius) {
                draggingBall = 'black';
            }

            if (!draggingBall && gameState === 'aiming' && cueBall.active) {
                gameState = 'pulling';
                pullStartPos = { x: pos.x, y: pos.y }; 
                pullEndPos = { x: pos.x, y: pos.y };
                event.preventDefault(); 
            }
            
            if (draggingBall && event.type === 'touchstart') {
                event.preventDefault();
            }
        }

        function handleDragEnd(event) {
            if (gameState === 'pulling') {
                gameState = 'simulating';
                
                const power = Math.hypot(pullEndPos.x - pullStartPos.x, pullEndPos.y - pullStartPos.y);
                
                if (soundsReady) {
                    const powerNormalized = Math.min(power / (TABLE_WIDTH * 0.2), 1);
                    cueHitSound.triggerAttackRelease("C3", "8n", Tone.now(), powerNormalized);
                }
                
                cueBall.vx = aimDir.x * power * POWER_MULTIPLIER;
                cueBall.vy = aimDir.y * power * POWER_MULTIPLIER;
                
                pullStartPos = null;
                pullEndPos = null;

            } else if (draggingBall) {
                draggingBall = null;
            }
        }

        function handleDragMove(event) {
            mousePos = getMousePosInCanvas(event);

            // CORRECCIÓN: Permitir apuntar y jalar al mismo tiempo en móvil
            if (event.type === 'touchmove' && (gameState === 'pulling' || gameState === 'aiming')) {
                if(gameState === 'aiming' && cueBall.active) {
                    // Si solo está apuntando (no ha empezado a jalar)
                    const dx = mousePos.x - cueBall.x;
                    const dy = mousePos.y - cueBall.y;
                    const mag = Math.hypot(dx, dy);
                    if (mag > 0.1) { 
                        aimDir.x = dx / mag;
                        aimDir.y = dy / mag;
                    }
                } else if (gameState === 'pulling') {
                    // Si está jalando
                    pullEndPos = { x: mousePos.x, y: mousePos.y };
                    // Actualizar también la dirección
                    const dx = mousePos.x - cueBall.x;
                    const dy = mousePos.y - cueBall.y;
                    const mag = Math.hypot(dx, dy);
                    if (mag > 0.1) { 
                        aimDir.x = dx / mag;
                        aimDir.y = dy / mag;
                    }
                }
                event.preventDefault();

            } else if (gameState === 'pulling') {
                // Ratón: solo actualiza la fuerza
                pullEndPos = { x: mousePos.x, y: mousePos.y }; 
                event.preventDefault();

            } else if (draggingBall) {
                let ballToMove;
                if (draggingG === 'cue') ballToMove = cueBall;
                else ballToMove = blackBall;

                ballToMove.x = clamp(mousePos.x, PLAYABLE_RECT.left + BALL_RADIUS, PLAYABLE_RECT.right - BALL_RADIUS);
                ballToMove.y = clamp(mousePos.y, PLAYABLE_RECT.top + BALL_RADIUS, PLAYABLE_RECT.bottom - BALL_RADIUS);

                if (event.type === 'touchmove') {
                    event.preventDefault();
                }
            } else if (gameState === 'aiming' && cueBall.active) {
                // Ratón: solo actualiza la dirección
                const dx = mousePos.x - cueBall.x;
                const dy = mousePos.y - cueBall.y;
                const mag = Math.hypot(dx, dy);
                if (mag > 0.1) { 
                    aimDir.x = dx / mag;
                    aimDir.y = dy / mag;
                }
            }
        }

        function updateSpin(pos) {
            const dx = pos.x - spinBallControl.x;
            const dy = pos.y - spinBallControl.y;
            const dist = Math.hypot(dx, dy);
            
            const maxDist = spinBallControl.radius * 0.8; 
            const clampedDist = Math.min(dist, maxDist);
            const angle = Math.atan2(dy, dx);

            spinIndicator.x = spinBallControl.x + Math.cos(angle) * clampedDist;
            spinIndicator.y = spinBallControl.y + Math.sin(angle) * clampedDist;

            spinEffect.x = (spinIndicator.x - spinBallControl.x) / maxDist;
            spinEffect.y = (spinIndicator.y - spinBallControl.y) / maxDist;
            
            drawSpinControl();
        }

        // --- NUEVA FUNCIÓN: Pantalla Completa ---
        function toggleFullScreen() {
            const elem = document.documentElement; // Usar el elemento raíz HTML
            
            if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                // Entrar en pantalla completa
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
            } else {
                // Salir de pantalla completa
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
            }
        }

        // --- ASIGNACIÓN DE EVENTOS ---
        canvas.addEventListener('mousedown', handleDragStart);
        window.addEventListener('mouseup', handleDragEnd); 
        canvas.addEventListener('mousemove', handleDragMove);

        canvas.addEventListener('touchstart', handleDragStart, { passive: false });
        window.addEventListener('touchend', handleDragEnd); 
        canvas.addEventListener('touchmove', handleDragMove, { passive: false });

        canvasSpin.addEventListener('mousedown', handleSpinStart);
        canvasSpin.addEventListener('mouseup', handleSpinEnd);
        canvasSpin.addEventListener('mousemove', handleSpinMove);
        canvasSpin.addEventListener('mouseout', handleSpinEnd);
        
        canvasSpin.addEventListener('touchstart', handleSpinStart, { passive: false });
        canvasSpin.addEventListener('touchend', handleSpinEnd);
        canvasSpin.addEventListener('touchmove', handleSpinMove, { passive: false });
        
        function handleSpinStart(event) {
            startAudioContext(); 
            if (event.type === 'touchstart') event.preventDefault();
            isSettingSpin = true;
            updateSpin(getMousePosInSpinCanvas(event));
        }
        
        function handleSpinEnd(event) {
            isSettingSpin = false;
        }

        function handleSpinMove(event) {
            if (!isSettingSpin) return;
            if (event.type === 'touchmove') event.preventDefault();
            updateSpin(getMousePosInSpinCanvas(event));
        }
        
        if(resetButton) {
            resetButton.addEventListener('click', resetBalls);
        }
        
        // NUEVO: Evento para el botón de pantalla completa
        if(fullscreenButton) {
            fullscreenButton.addEventListener('click', toggleFullScreen);
            // Usar 'touchstart' para respuesta más rápida en móviles
            fullscreenButton.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Evitar "click fantasma"
                toggleFullScreen();
            });
        }
        
        window.addEventListener('resize', setupCanvas);

        // Ajustar el canvas de spin una vez
        function setupSpinControl() {
            canvasSpin.width = 100;
            canvasSpin.height = 100;
            spinBallControl.radius = canvasSpin.width * 0.4; 
            spinBallControl.x = canvasSpin.width / 2;
            spinBallControl.y = canvasSpin.height / 2;
        }

        // --- 10. INICIO DE LA APLICACIÓN ---
        setupSpinControl(); 
        setupCanvas(); 
        mousePos = { x: canvas.width / 2, y: canvas.height / 2}; 
        gameLoop();    
        drawSpinControl(); 
    
    </script>

</body>
</html>

